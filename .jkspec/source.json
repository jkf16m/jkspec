{
  "project": {
    "name": "jkspec",
    "description": "JSON-based specification format for rapid AI agent context retrieval. Provides jkspec-template as a starter template for projects.",
    "version": "0.1.0",
    "architecture": {
      "style": "single-file specification",
      "pattern": "spec-driven development",
      "philosophy": "Provide AI agents with structured, queryable context to eliminate codebase exploration overhead"
    },
    "conventions": {
      "spec_location": ".jkspec/source.json",
      "query_tool": "jq",
      "spec_keys": "Use kebab-case for spec identifiers (e.g., 'auth-service', 'user-model')",
      "internal_specs": "Specs prefixed with __ are internal/meta specs (e.g., '__jkspec')",
      "versioning": "Semantic versioning for the spec format itself",
      "dual_file_architecture": "Framework specs stay in .jkspec/source.json. All user specs MUST live in .jkspec-project/project.json (auto-created on bootstrap).",
      "schema_validation": "Both files validate against .jkspec/jkspec.schema.json using ajv"
    },
    "decisions": [
      {
        "id": "ADR-001",
        "title": "Use single JSON file as source of truth",
        "status": "accepted",
        "date": "2025-12-25",
        "context": "AI agents waste time exploring codebases. Need fast, precise context retrieval.",
        "decision": "Use single .jkspec/source.json file with structured data, queryable via jq",
        "consequences": "Agents get instant context. Must maintain spec alongside code. JSON parsing overhead minimal."
      },
      {
        "id": "ADR-002",
        "title": "Use object for specs instead of array",
        "status": "accepted",
        "date": "2025-12-25",
        "context": "Need to avoid duplicate keys and enable direct access",
        "decision": "Use object with unique keys for specs: {\"spec-name\": {...}}",
        "consequences": "Direct access via jq '.specs[\"name\"]'. Natural key uniqueness. Slightly more verbose queries for filtering."
      },
      {
        "id": "ADR-003",
        "title": "Use __ prefix for internal specs",
        "status": "accepted",
        "date": "2025-12-25",
        "context": "Need to distinguish internal jkspec infrastructure from user specs",
        "decision": "Prefix internal/meta specs with __ (double underscore) to clearly mark them as part of jkspec itself",
        "consequences": "Users can easily identify and avoid modifying internal specs. Clear separation of concerns between framework and user content."
      },
      {
        "id": "ADR-004",
        "title": "Remove CLI abstraction, use jq directly",
        "status": "accepted",
        "date": "2025-12-25",
        "context": "CLI tool adds complexity and maintenance burden. AI agents are fluent in jq. Direct manipulation is more transparent.",
        "decision": "Remove jkspec CLI tool. Use jq directly for all read/write operations on .jkspec/source.json",
        "consequences": "Simpler architecture with fewer moving parts. Agent can see exact jq commands. Users learn standard jq instead of custom CLI. Slightly more verbose operations but more transparent and flexible."
      },
      {
        "id": "ADR-005",
        "title": "Separate jkspec framework from project specifications using dual-file architecture",
        "status": "accepted",
        "date": "2025-12-25",
        "context": "Users need to update jkspec tooling without affecting their project data. Currently .jkspec/source.json mixes framework specs (__jkspec) with project specs, making updates risky and cumbersome.",
        "decision": "Split into two files: .jkspec/source.json (framework only with __jkspec specs) and .jkspec-project/project.json (user project specs). Both use the same schema. Agents check for .jkspec-project/ on init and create if missing.",
        "consequences": "Users can update jkspec by deleting .jkspec/ and cloning fresh. Project data in .jkspec-project/project.json remains safe. Commands must implement file selection logic based on spec-id prefix. Slightly more complex for agents but much cleaner separation of concerns."
      }
    ]
  },
  "specs": {
    "__jkspec": {
      "__meta": {
        "type": "meta",
        "description": "Internal jkspec system specification - contains all jkspec infrastructure components",
        "status": "active",
        "tags": [
          "internal",
          "meta",
          "jkspec-system"
        ],
        "note": "This is an internal spec. User specs should not use the __ prefix."
      },
      "components": {
        "format": {
          "__meta": {
            "type": "specification",
            "description": "The jkspec format itself - structure and conventions",
            "status": "active",
            "tags": [
              "meta",
              "format"
            ],
            "location": ".jkspec/source.json"
          },
          "structure": {
            "project": {
              "name": "string - project name",
              "description": "string - brief project description",
              "version": "string - semver",
              "architecture": "object - architectural overview",
              "conventions": "object - global coding and organizational conventions",
              "decisions": "array - architectural decision records"
            },
            "specs": {
              "description": "object - keyed by unique spec identifier",
              "spec_schema": {
                "__meta": {
                  "core_fields": {
                    "type": "string - spec type (api, model, component, feature, etc.)",
                    "description": "string - what this spec describes",
                    "status": "string - draft, active, deprecated",
                    "tags": "array - searchable tags for filtering and categorization"
                  },
                  "optional_fields": {
                    "location": "string - file path or directory where this spec is implemented",
                    "purpose": "string - why this spec exists or what problem it solves",
                    "dependencies": "array - list of dependencies (packages, libraries, other specs)",
                    "note": "string - additional notes or warnings about this spec",
                    "complexity": "string - low, medium, high - indicates implementation complexity",
                    "subagent_required": "boolean - true if spec is complex enough to warrant spawning a dedicated subagent for implementation"
                  },
                  "description": "All specs must have a __meta object with at minimum the core fields. Optional fields provide additional context and control."
                },
                "...": "any additional fields relevant to the spec"
              }
            }
          },
          "examples": {
            "get_project_info": "jq \".project\" .jkspec/source.json",
            "list_all_specs": "jq \".specs | keys\" .jkspec/source.json",
            "get_specific_spec": "jq \".specs[\\\"spec-name\\\"]\" .jkspec/source.json",
            "get_spec_meta": "jq \".specs[\\\"spec-name\\\"].__meta\" .jkspec/source.json",
            "filter_by_type": "jq \".specs | to_entries[] | select(.value.__meta.type==\\\"api\\\")\" .jkspec/source.json",
            "filter_by_tag": "jq \".specs | to_entries[] | select(.value.__meta.tags[]? == \\\"authentication\\\")\" .jkspec/source.json",
            "filter_by_status": "jq \".specs | to_entries[] | select(.value.__meta.status == \\\"draft\\\")\" .jkspec/source.json"
          },
          "hierarchical_specifications": {
            "description": "Specs can contain nested child specifications at any depth using arbitrary keys",
            "common_keys": [
              "children",
              "specs",
              "tests",
              "endpoints",
              "components",
              "requirements"
            ],
            "status_lifecycle": {
              "draft": "Specification not yet implemented",
              "active": "Specification fully implemented and working",
              "deprecated": "Specification no longer in use"
            },
            "philosophy": "Instead of redoing implementations, refine specs by adding more detailed child specifications to achieve more accurate results"
          },
          "nested_examples": {
            "simple_nesting": {
              "parent_spec": "__jkspec",
              "child_key": "components",
              "children": {
                "format": {
                  "__meta": {
                    "type": "specification",
                    "description": "The jkspec format specification",
                    "status": "active"
                  }
                }
              }
            },
            "deep_nesting": {
              "description": "Specs can nest arbitrarily deep with each level having its own __meta",
              "example": "auth-api > endpoints > login > validations > email-format",
              "structure": {
                "auth-api": {
                  "__meta": {
                    "type": "api",
                    "description": "Authentication API",
                    "status": "active"
                  },
                  "endpoints": {
                    "login": {
                      "__meta": {
                        "type": "endpoint",
                        "description": "Login endpoint",
                        "status": "active"
                      },
                      "validations": {
                        "email-format": {
                          "__meta": {
                            "type": "validation",
                            "description": "Email format validation",
                            "status": "active"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "jq_editing_examples": {
            "add_new_spec": "jq \".specs[\\\"new-spec-id\\\"] = {__meta: {type: \\\"component\\\", description: \\\"New component\\\", status: \\\"draft\\\", tags: [\\\"frontend\\\"]}}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "update_meta_field": "jq \".specs[\\\"spec-id\\\"].__meta.status = \\\"active\\\"\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "remove_spec": "jq \"del(.specs[\\\"spec-id\\\"])\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "add_nested_child": "jq \".specs[\\\"parent-id\\\"].children[\\\"child-id\\\"] = {__meta: {type: \\\"subcomponent\\\", description: \\\"Child spec\\\", status: \\\"draft\\\"}}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "update_nested_meta": "jq \".specs[\\\"parent-id\\\"].children[\\\"child-id\\\"].__meta.status = \\\"active\\\"\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "add_tag": "jq \".specs[\\\"spec-id\\\"].__meta.tags += [\\\"new-tag\\\"]\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "remove_tag": "jq \".specs[\\\"spec-id\\\"].__meta.tags -= [\\\"old-tag\\\"]\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "add_task": "jq \".specs[\\\"spec-id\\\"].tasks += [{name: \\\"Task name\\\", description: \\\"Task description\\\", done: false}]\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "mark_task_done": "jq \".specs[\\\"spec-id\\\"].tasks[0].done = true\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "update_multiple_meta": "jq \".specs[\\\"spec-id\\\"].__meta |= . + {status: \\\"active\\\", location: \\\"path/to/file\\\"}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "add_data_field": "jq \".specs[\\\"spec-id\\\"].custom_data = {key: \\\"value\\\"}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json"
          },
          "documentation_bindings": {
            "readme_spec": "__jkspec.components.readme-documentation",
            "sections": [
              "what_is_jkspec",
              "core_concepts",
              "examples"
            ],
            "implementation_output": "README.md",
            "update_trigger": "When format spec status is draft, keep readme-documentation in draft until README reflects new structural rules.",
            "rationale": "Format spec defines core structure and jq usage guidance that surface in README sections."
          }
        },
        "depth-system": {
          "__meta": {
            "type": "feature",
            "description": "Single unified agent architecture where jkspec-worker handles all operations from high-level management to detailed implementation",
            "status": "active",
            "tags": [
              "architecture",
              "unified-agent"
            ],
            "purpose": "Simplified architecture with one agent that can handle any jkspec task",
            "location": ".opencode/agent/"
          },
          "concepts": {
            "spec_levels": {
              "simple": "Single file, small component, or focused investigation",
              "medium": "Module, service, or feature with multiple files",
              "complex": "System, architecture, or large-scale feature spanning multiple modules"
            },
            "unified_approach": "Single agent handles both management operations (add/update/validate specs) and implementation work (read/implement/verify specs)"
          },
          "agent_responsibilities": {
            "jkspec-worker": "Handles ALL operations: extends specs, validates structure, analyzes codebase, implements features, explains specs, and verifies implementations"
          },
          "implemented_in": [
            ".opencode/agent/jkspec-worker.md"
          ]
        },
        "worker": {
          "bootstrap": {
            "first_command": "jq '.specs.__jkspec.components.worker | with_entries(.value |= (if type == \"object\" then .description else . end))' .jkspec/source.json",
            "description": "On initialization, agent must read the worker object which contains all operational definitions",
            "__meta": {
              "type": "config",
              "description": "Defines initialization steps and first command executed when the worker starts",
              "status": "active"
            }
          },
          "commands_location": ".opencode/command",
          "commands_description": "All jkspec-worker commands are defined as minimal markdown files in .opencode/command/ directory. Each command file references a jq query to fetch the full command definition from .jkspec/source.json at .specs.__jkspec.components.worker.commands_definitions.<command-name>",
          "available_commands": [
            "jkspec-extend",
            "jkspec-deepen",
            "jkspec-implement",
            "jkspec-dev-mode"
          ],
          "reading_policy": {
            "description": "Use jq directly to read and manipulate .jkspec/source.json",
            "philosophy": "Direct JSON manipulation with jq is simpler and more transparent than abstracting behind a CLI tool",
            "common_operations": {
              "read_spec": "jq \".specs[\\\"spec-id\\\"]\" .jkspec/source.json",
              "read_spec_meta": "jq \".specs[\\\"spec-id\\\"].__meta\" .jkspec/source.json",
              "list_specs": "jq \".specs | keys\" .jkspec/source.json",
              "get_worker_config": "jq \".worker\" .jkspec/source.json",
              "get_project_info": "jq \".project\" .jkspec/source.json",
              "filter_by_type": "jq \".specs | to_entries[] | select(.value.__meta.type == \\\"api\\\")\" .jkspec/source.json",
              "filter_by_status": "jq \".specs | to_entries[] | select(.value.__meta.status == \\\"draft\\\")\" .jkspec/source.json"
            },
            "best_practices": [
              "Always use tmp.json pattern when modifying: jq '...' file.json > tmp.json && mv tmp.json file.json",
              "Validate JSON after modifications with: jq empty .jkspec/source.json",
              "Use --arg for passing variables to avoid shell escaping issues",
              "Use -r flag for raw output when you need unquoted strings",
              "Test complex jq queries with read-only operations first"
            ],
            "__meta": {
              "type": "policy",
              "description": "Explains how the worker reads and modifies specs using jq",
              "status": "active"
            }
          },
          "guidelines": [
            "Always validate input - check spec-id naming conventions and required fields",
            "Use jq for all spec reading and modifications",
            "Be concise and provide clear, actionable output",
            "Show results after operations",
            "Handle errors gracefully with explanations",
            "Follow kebab-case convention for spec IDs",
            "Be autonomous within spec scope",
            "Ensure thorough implementation according to requirements",
            "Dual-file architecture: Check for .jkspec-project/project.json for user project specs, use .jkspec/source.json for framework specs",
            "File selection: Specs with __ prefix go to source.json (framework), specs without __ prefix go to project.json (user project)",
            "Auto-create project.json: If .jkspec-project/project.json does not exist, create it with minimal template on first user spec operation",
            "Always validate both source.json and project.json against jkspec.schema.json using ajv",
            "After ANY modification to source.json or project.json, IMMEDIATELY validate against jkspec.schema.json using: ajv validate -s .jkspec/jkspec.schema.json -d <file> --spec=draft2020 --strict=false. If validation fails, fix the issue before proceeding.",
            "Default spec queries MUST target .jkspec-project/project.json unless the user explicitly requests framework specs.",
            "Do not mention meta-specs or __jkspec components unless the user prompts for them.",
            "New spec creation: Always add specs to .jkspec-project/project.json and never ask users to choose a scope unless they explicitly request a __ prefixed internal spec.",
            "After creating or updating any spec, export it to Markdown using .jkspec/cli/make_md_view.sh into .tmp/<spec-id>.md and share the inspection path with the user"
          ],
          "complex_specs": {
            "description": "How to handle specs with multiple components",
            "approach": [
              "Identify child specs (look for children, specs, tests fields)",
              "Break down work into components",
              "Implement systematically through each component",
              "Track progress and update status fields",
              "Report comprehensively on all components"
            ],
            "__meta": {
              "type": "guideline",
              "description": "Guidance for handling multi-component or deeply nested specifications",
              "status": "active"
            }
          },
          "subagent_policy": {
            "description": "When and how jkspec-worker spawns subagents for complex implementation tasks",
            "when_to_spawn": [
              "Spec has subagent_required: true in __meta",
              "Spec has complexity: high and involves significant implementation work",
              "User explicitly requests subagent usage",
              "Implementation involves multiple files or coordinated changes",
              "Task requires sustained focus beyond simple edits"
            ],
            "how_to_spawn": {
              "use_task_tool": "Use the Task tool to spawn general-purpose subagent",
              "provide_full_spec": "Pass complete spec details to subagent including all requirements, tasks, and constraints",
              "clear_instructions": "Give subagent explicit instructions on what to implement and how to verify correctness",
              "result_reporting": "Subagent should report back implementation status and any issues encountered"
            },
            "worker_responsibilities": [
              "Read and understand spec before spawning subagent",
              "Determine if subagent is needed based on complexity",
              "Prepare comprehensive prompt for subagent with all necessary context",
              "Monitor subagent work and integrate results",
              "Update spec status and tasks array after subagent completes work"
            ],
            "example_workflow": "1. Read spec with jq\n2. Check complexity and subagent_required fields\n3. If needed, use Task tool to spawn subagent with full spec context\n4. Subagent implements according to spec requirements\n5. Worker verifies implementation and updates spec status",
            "__meta": {
              "type": "policy",
              "description": "Rules for when and how the worker should spawn subagents",
              "status": "active"
            }
          },
          "greeting": {
            "style": "minimal",
            "message": "Initialized and ready.",
            "include_commands_list": false,
            "rationale": "Keep greeting concise - user can ask for help if needed",
            "__meta": {
              "type": "behavior",
              "description": "Defines the greeting tone, message, and rationale for user interactions",
              "status": "active"
            },
            "description": "Defines greeting style, message, and rationale"
          },
          "commands_definitions": {
            "extend": {
              "description": "Add a new spec to the appropriate jkspec file",
              "steps": [
                "Determine target file: If spec-id starts with __, use .jkspec/source.json (framework), otherwise use .jkspec-project/project.json (user project)",
                "Check if .jkspec-project/project.json exists, create with minimal template if needed for user specs",
                "Validate the spec-id follows kebab-case convention",
                "Check if spec already exists: jq \".specs[\\\"<spec-id>\\\"]\" <target-file>",
                "Use jq to add the spec with full __meta payload and any requested fields",
                "Validate the modified file against schema: ajv validate -s .jkspec/jkspec.schema.json -d <target-file> --spec=draft2020 --strict=false",
                "Confirm success and show the added spec: jq \".specs[\\\"<spec-id>\\\"]\" <target-file>"
              ]
            },
            "deepen": {
              "description": "Transform a shallow spec into a richer hierarchy by adding detailed child specs, tasks, or metadata",
              "steps": [
                "Identify the target spec and determine source file based on prefix",
                "Read current spec structure incrementally to understand existing __meta, children, and tasks",
                "Work with the user to pinpoint which areas need deeper coverage (e.g., break out children, add tasks, capture locations/dependencies)",
                "Add or update nested child specs under keys like children/specs/tests with their own __meta objects",
                "Augment traceability fields (tasks array, dependencies, notes) to reflect the new depth",
                "Update relevant statuses/tags if the spec maturity changes",
                "Validate the modified file and show the updated portion of the spec"
              ],
              "deepening_patterns": [
                "Split high-level specs into child specs for each subsystem",
                "Add validation/test children for APIs",
                "Use tasks array to document implementation steps",
                "Attach location/dependency metadata for each new child"
              ]
            },
            "implement": {
              "description": "Review all draft specs, select a target, and drive it to implementation",
              "steps": [
                "List every draft spec across source.json and project.json using jq filters (status == \"draft\")",
                "Present the draft list and pick the spec to implement (or ask the user to choose)",
                "Read the chosen spec in detail, noting tasks, dependencies, and locations",
                "Execute the implementation plan (code changes, tests, documentation) or spawn a subagent if complexity demands it",
                "Update spec tasks and status (mark tasks done, set status to active when complete)",
                "Validate the edited spec file and summarize the implementation outcome"
              ],
              "draft_query": "jq \".specs | to_entries[] | select(.value.__meta.status == \\\"draft\\\")\" <file>"
            },
            "dev-mode": {
              "description": "Enter focused developer mode for modifying internal specs, defined as any component nested under __jkspec (i.e., __ prefixed jkspec infrastructure specs)",
              "steps": [
                "Confirm intent to edit internal specs and review modification_policy guidance",
                "List relevant __ prefixed specs to scope the work using jq '.specs.__jkspec.components | keys' .jkspec/source.json",
                "Load the necessary internal spec sections (e.g., worker object, commands, guidelines)",
                "Plan the required changes, capturing affected commands/guidelines before editing",
                "Apply updates using jq, keeping changes scoped to .jkspec/source.json",
                "Validate the file immediately after edits and report the internal spec adjustments"
              ],
              "dev_mode_principles": [
                "Only edit __ prefixed specs while in this mode",
                "Reference modification_policy expectations before changing internal behavior",
                "Document rationale for internal changes in the response",
                "Never query or access project specs (.jkspec-project/project.json) while in dev-mode; limit interactions strictly to internal __-prefixed specs."
              ]
            },
            "__meta": {
              "type": "reference",
              "description": "Detailed definitions, steps, and principles for each worker command",
              "status": "active"
            },
            "description": "Step-by-step definitions for each worker command"
          },
          "__meta": {
            "type": "agent",
            "description": "Unified agent for managing and implementing jkspec specifications - handles both high-level management operations and detailed implementation work",
            "status": "active",
            "tags": [
              "ai-agents",
              "management",
              "implementation"
            ],
            "purpose": "Single agent that can extend, validate, maintain jkspec files AND read/implement individual specs using jq directly",
            "location": ".opencode/agent/jkspec-worker.md",
            "dependencies": [
              "jq"
            ]
          },
          "capabilities": {
            "management": [
              "Add new specs (extend command)",
              "Update existing specs (update command)",
              "Validate jspec structure (validate command)",
              "Analyze specs and provide recommendations (analyze command)",
              "Suggest missing specs (suggest-specs command)",
              "Verify implementation status (test-sync command)"
            ],
            "implementation": [
              "Read and explain spec details (explain command)",
              "Implement specs according to requirements (implement command)",
              "Verify implementations match specs (verify command)",
              "Work with complex multi-component specs"
            ],
            "__meta": {
              "type": "reference",
              "description": "Catalog of management and implementation capabilities exposed by the worker",
              "status": "active"
            },
            "description": "Summary of management and implementation capabilities"
          },
          "commands": {
            "extend": "Add a new spec to the jspec file",
            "update": "Update an existing spec field",
            "validate": "Validate the jspec structure and check for inconsistencies",
            "analyze": "Analyze the current jkspec structure and provide recommendations",
            "suggest-specs": "Suggest missing specs based on codebase analysis",
            "test-sync": "Verify that all specs have corresponding implementations",
            "implement": "Implement a spec according to its requirements",
            "explain": "Read and explain a specific spec's details",
            "verify": "Verify if a spec is implemented correctly",
            "__meta": {
              "type": "reference",
              "description": "Mapping of command names to their functional purpose",
              "status": "active"
            },
            "description": "Maps command names to their high-level purposes"
          },
          "jq_operations": {
            "reading": {
              "get_spec": "jq \".specs[\\\"spec-id\\\"]\" .jkspec/source.json",
              "get_spec_meta": "jq \".specs[\\\"spec-id\\\"].__meta\" .jkspec/source.json",
              "get_nested_spec": "jq \".specs[\\\"parent-id\\\"].children[\\\"child-id\\\"]\" .jkspec/source.json",
              "get_nested_meta": "jq \".specs[\\\"parent-id\\\"].children[\\\"child-id\\\"].__meta\" .jkspec/source.json",
              "list_all_specs": "jq \".specs | keys\" .jkspec/source.json",
              "list_specs_by_type": "jq \".specs | to_entries[] | select(.value.__meta.type == \\\"api\\\") | .key\" .jkspec/source.json",
              "list_specs_by_tag": "jq \".specs | to_entries[] | select(.value.__meta.tags[]? == \\\"backend\\\") | .key\" .jkspec/source.json",
              "get_all_draft_specs": "jq \".specs | to_entries[] | select(.value.__meta.status == \\\"draft\\\")\" .jkspec/source.json",
              "get_project_info": "jq \".project\" .jkspec/source.json"
            },
            "writing": {
              "add_spec": "jq \".specs[\\\"new-spec\\\"] = {__meta: {type: \\\"component\\\", description: \\\"Description\\\", status: \\\"draft\\\", tags: []}}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "update_meta_field": "jq \".specs[\\\"spec-id\\\"].__meta.status = \\\"active\\\"\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "add_data_field": "jq \".specs[\\\"spec-id\\\"].new_field = \\\"value\\\"\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "add_nested_spec": "jq \".specs[\\\"parent\\\"].children[\\\"child\\\"] = {__meta: {type: \\\"type\\\", description: \\\"desc\\\", status: \\\"draft\\\"}}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "add_tag": "jq \".specs[\\\"spec-id\\\"].__meta.tags += [\\\"new-tag\\\"]\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "update_multiple_meta": "jq \".specs[\\\"spec-id\\\"].__meta |= . + {status: \\\"active\\\", location: \\\"path/to/file\\\"}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json"
            },
            "deleting": {
              "remove_spec": "jq \"del(.specs[\\\"spec-id\\\"])\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "remove_nested": "jq \"del(.specs[\\\"parent\\\"].children[\\\"child\\\"])\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "remove_data_field": "jq \"del(.specs[\\\"spec-id\\\"].field_name)\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "remove_tag": "jq \".specs[\\\"spec-id\\\"].__meta.tags -= [\\\"tag-to-remove\\\"]\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "remove_meta_field": "jq \"del(.specs[\\\"spec-id\\\"].__meta.field_name)\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json"
            },
            "advanced": {
              "conditional_update": "jq \".specs |= with_entries(if .value.__meta.status == \\\"draft\\\" then .value.__meta.status = \\\"reviewed\\\" else . end)\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "bulk_add_meta_field": "jq \".specs |= with_entries(.value.__meta.updated = \\\"2025-12-25\\\")\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "deep_merge_data": "jq \".specs[\\\"spec-id\\\"] |= . * {new_field: \\\"value\\\", nested: {key: \\\"val\\\"}}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "filter_and_rebuild": "jq \".specs |= with_entries(select(.value.__meta.status != \\\"deprecated\\\"))\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "list_draft_paths": {
                "description": "List dot-delimited JSON paths for every draft spec",
                "project_command": "jq -r \"paths(objects | select(has(\\\"__meta\\\") and .__meta.status == \\\"draft\\\")) | map(tostring) | join(\\\".\\\")\" .jkspec-project/project.json",
                "dev_mode_command": "jq -r \"paths(objects | select(has(\\\"__meta\\\") and .__meta.status == \\\"draft\\\")) | select(.[0] == \\\"specs\\\" and .[1] == \\\"__jkspec\\\") | map(tostring) | join(\\\".\\\")\" .jkspec/source.json",
                "usage_notes": "Always run the project command first (covers user specs). Only run the dev mode command when explicitly working on __ prefixed internal specs inside source.json."
              }
            },
            "__meta": {
              "type": "reference",
              "description": "Library of jq snippets for reading and editing specs",
              "status": "active"
            },
            "description": "Library of jq snippets for reading, writing, deleting, and advanced operations"
          },
          "workflow": {
            "description": "Worker follows a consultative approach when helping users implement new specs",
            "new_spec_creation": {
              "phase_1_gather_requirements": {
                "description": "Before writing any spec, worker asks clarifying questions to understand all details",
                "questions_to_ask": [
                  "What is the spec ID (kebab-case)?",
                  "What type is this spec (api, component, model, feature, etc.)?",
                  "What is the purpose/description of this spec?",
                  "What files/locations will be affected?",
                  "Are there any dependencies or related specs?",
                  "What tags should be applied?",
                  "Should this include a tasks array for traceability?",
                  "Are there nested child specs or components?",
                  "What is the expected behavior or implementation details?"
                ],
                "approach": "Ask questions conversationally, not as a checklist. Adapt based on user responses and spec type.",
                "goal": "Gather complete understanding before proposing any spec structure"
              },
              "phase_2_propose_draft": {
                "description": "Once all details are clear, propose a complete draft spec structure",
                "actions": [
                  "Show the proposed JSON structure to the user",
                  "Explain the structure and any design decisions",
                  "Ask for confirmation or adjustments"
                ]
              },
              "phase_3_write_spec": {
                "description": "After user approval, write the spec to source.json",
                "actions": [
                  "Use jq to add the spec with status: draft",
                  "Validate the JSON structure",
                  "Confirm successful creation",
                  "Show the final spec to the user"
                ]
              }
            },
            "philosophy": "Measure twice, cut once - thorough understanding before implementation prevents rework",
            "__meta": {
              "type": "process",
              "description": "Prescribed workflow for creating and updating specs",
              "status": "active"
            }
          },
          "context_management": {
            "description": "Strategy for querying JSON specs to maintain efficient context usage",
            "principles": [
              "Query first level of depth for broad context awareness",
              "Include worker context itself in initial bootstrap",
              "Dynamically extend context selectively based on actual needs",
              "Avoid loading large nested JSON objects upfront"
            ],
            "bootstrap_queries": {
              "worker_config": "jq '.worker' .jkspec/source.json",
              "project_overview": "jq '.project' .jkspec/source.json",
              "spec_list": "jq '.specs | keys' .jkspec/source.json",
              "spec_first_level": "jq '.specs | with_entries(.value |= {__meta})' .jkspec/source.json"
            },
            "selective_deepening": {
              "description": "Only query deeper levels when specific information is needed",
              "examples": {
                "when_needed": "User asks to implement a specific spec",
                "query_pattern": "jq '.specs[\"specific-spec\"]' .jkspec/source.json",
                "nested_when_needed": "jq '.specs[\"parent\"].children[\"child\"]' .jkspec/source.json"
              }
            },
            "rationale": "Maintains efficient context window usage by loading only necessary information. Worker starts with high-level overview and drills down selectively rather than loading entire nested structures.",
            "__meta": {
              "type": "policy",
              "description": "Strategy for incremental context gathering and selective deepening",
              "status": "active"
            }
          },
          "modification_policy": {
            "description": "Guidelines for modifying worker behavior and understanding impact scope",
            "json_modifications": {
              "scope": "Changes to worker object in .jkspec/source.json",
              "impact": "Does NOT require CLI agent tooling reset",
              "reason": "Worker recontextualizes itself dynamically by reading worker object on bootstrap",
              "examples": [
                "Adding new guidelines",
                "Modifying commands list",
                "Updating policies",
                "Adding workflow steps",
                "Changing context management strategy"
              ],
              "agent_behavior": "Worker reads .worker on initialization via bootstrap command, so changes take effect immediately on next invocation"
            },
            "agent_file_modifications": {
              "scope": "Changes to .opencode/agent/jkspec-worker.md agent definition file",
              "impact": "REQUIRES full reset of CLI agent tooling",
              "reason": "Agent file defines core agent initialization, tools, and system prompts that are loaded by CLI at startup",
              "examples": [
                "Modifying agent system prompt",
                "Changing bootstrap instructions",
                "Updating tool access patterns",
                "Altering core agent behavior"
              ],
              "reset_procedure": "Restart or reinitialize the CLI agent tooling to reload the agent definition file"
            },
            "command_file_modifications": {
              "scope": "Changes to individual command files in .opencode/commands/",
              "impact": "Does NOT require CLI reset (similar to JSON modifications)",
              "reason": "Command files are read dynamically when commands are invoked",
              "note": "Worker reads command markdown files on-demand when executing specific commands"
            },
            "best_practice": "Prefer modifying worker JSON object for behavioral changes to avoid needing CLI resets. Reserve agent file modifications for fundamental structural changes.",
            "__meta": {
              "type": "policy",
              "description": "Guidance for editing worker JSON, agent files, and command files",
              "status": "active"
            }
          },
          "incremental_traversal": {
            "commandment": "ALWAYS use incremental queries when exploring specs. Start with keys only, then drill down to specific fields as needed. Never read entire large objects unnecessarily.",
            "rationale": "Efficiency and clarity - only fetch data you actually need at each step",
            "approach": [
              "Step 1: List keys to understand structure",
              "Step 2: Check existence or filter by metadata",
              "Step 3: Fetch specific fields or nested keys as needed",
              "Step 4: Only read full objects when absolutely necessary"
            ],
            "examples": {
              "explore_spec": [
                "jq \".specs | keys\" - First see what specs exist",
                "jq \".specs | has(\\\"spec-id\\\")\" - Check if specific spec exists",
                "jq \".specs[\\\"spec-id\\\"] | keys\" - See structure of spec",
                "jq \".specs[\\\"spec-id\\\"].__meta\" - Get metadata",
                "jq \".specs[\\\"spec-id\\\"].specific_field\" - Get specific field only"
              ],
              "explore_nested": [
                "jq \".specs[\\\"parent\\\"].children | keys\" - List child specs",
                "jq \".specs[\\\"parent\\\"].children[\\\"child\\\"] | keys\" - See child structure",
                "jq \".specs[\\\"parent\\\"].children[\\\"child\\\"].__meta.status\" - Get specific nested field"
              ]
            },
            "anti_patterns": [
              "Reading entire .specs object when you only need keys",
              "Fetching full spec when you only need to check existence",
              "Getting all fields when you only need __meta",
              "Reading large nested structures when you only need to know what keys exist"
            ],
            "__meta": {
              "type": "guideline",
              "description": "Instructions for incremental exploration of specs and avoiding anti-patterns",
              "status": "active"
            },
            "description": "Protocol for incrementally traversing spec trees efficiently"
          },
          "documentation_bindings": {
            "produces": [
              "README.md"
            ],
            "documentation_specs": [
              "__jkspec.components.readme-documentation"
            ],
            "responsibilities": [
              "Mark readme-documentation.__meta.status = \"draft\" when any referenced meta-spec is modified",
              "Regenerate README.md from template before reactivating readme-documentation"
            ],
            "automation_hooks": {
              "validation": "jkspec-validate checks if readme-documentation status is draft and emits reminder to regenerate README",
              "implementation": "jkspec-implement readme-documentation executes README regeneration steps"
            },
            "__meta": {
              "type": "guideline",
              "description": "Rules for documentation outputs, bindings, and automation hooks",
              "status": "active"
            },
            "description": "Rules connecting specs to documentation outputs and automation hooks"
          },
          "view_inspection": {
            "__meta": {
              "type": "guideline",
              "status": "draft",
              "tags": [
                "worker",
                "inspection",
                "cli"
              ],
              "created": "2025-12-26T05:51:56Z",
              "updated": "2025-12-26T05:51:56Z",
              "description": "Ensure workers generate Markdown inspection views for every new or updated spec using the dedicated CLI tool"
            },
            "problem": {
              "context": "Specs live as JSON which is hard for users to skim right after creation.",
              "pain_points": [
                "Users cannot easily review spec details without running jq queries",
                "Fresh specs may contain mistakes that go unnoticed without a readable view",
                "There is no automated habit enforcing view generation"
              ],
              "goal": "Provide an immediate, human-readable Markdown snapshot for each spec change."
            },
            "deliverables": {
              "cli_tool": {
                "path": ".jkspec/cli/make_md_view.sh",
                "description": "Shell script that accepts a spec-id, JSON file path, and Markdown output path, then renders a deterministic Markdown view using jq.",
                "requirements": [
                  "Support any spec JSON structure that follows jkspec conventions",
                  "Gracefully handle missing optional sections by skipping them",
                  "Create parent directories for the output path automatically",
                  "Exit with non-zero status on invalid input"
                ]
              },
              "worker_guideline": {
                "description": "Operational rule instructing workers to render Markdown views immediately after writing or updating a spec.",
                "output_location": ".tmp/<spec-id>.md",
                "rationale": "Keeps review loop tight and gives users a document they can open without tooling"
              }
            },
            "requirements": [
              {
                "id": "req-cli-view",
                "title": "CLI Markdown renderer",
                "priority": "critical",
                "description": "Implement make_md_view.sh to convert spec JSON into a Markdown document with sections for meta, problem, requirements, implementation, testing, tasks, and notes."
              },
              {
                "id": "req-tmp-folder",
                "title": "Temporary inspection workspace",
                "priority": "high",
                "description": "Ensure a top-level .tmp directory exists and always house rendered Markdown files there using the <spec-id>.md naming pattern."
              },
              {
                "id": "req-workflow",
                "title": "Post-spec workflow",
                "priority": "high",
                "description": "Immediately after adding or editing a spec, export the spec JSON to a temp file and run the CLI to generate the Markdown view, then surface the output path in responses."
              }
            ],
            "workflow": {
              "steps": [
                "Finish jq edits to the target spec",
                "Validate the JSON file",
                "Create .tmp if it does not exist",
                "Export the spec JSON with jq to a temporary file",
                "Run .jkspec/cli/make_md_view.sh <spec-id> <json-path> .tmp/<spec-id>.md",
                "Reference the generated Markdown path in the user-facing summary"
              ],
              "automation_notes": "Future automation can watch .tmp for stale files and regenerate automatically"
            },
            "tasks": [
              {
                "name": "Create CLI tool",
                "description": "Author make_md_view.sh with jq-based Markdown rendering",
                "done": false
              },
              {
                "name": "Add worker guideline",
                "description": "Append rule requiring Markdown view generation for each new/updated spec",
                "done": false
              },
              {
                "name": "Demonstrate sample output",
                "description": "Generate a Markdown file for the latest spec to show the workflow",
                "done": false
              }
            ],
            "notes": [
              "Store renderer outputs outside git-tracked areas to avoid noise (hence .tmp)",
              "Leverage jq exclusively so the script remains dependency-light"
            ]
          },
          "tasks": [
            {
              "name": "Render Markdown view for latest spec",
              "description": "Use make_md_view.sh to generate .tmp/<spec-id>.md after spec updates",
              "done": true
            }
          ]
        },
        "traceability": {
          "__meta": {
            "type": "meta-guideline",
            "description": "Guideline for creating traceable specs with implementation status tracking using task arrays",
            "status": "active",
            "tags": [
              "meta",
              "guideline",
              "traceability"
            ],
            "purpose": "Define a standardized pattern for tracking implementation tasks within specs to ensure clear traceability between specification and actual code"
          },
          "concept": "When creating code-related specs, include a tasks array where each element is a task object containing name, description, and done status",
          "pattern": {
            "tasks": {
              "description": "Array of task objects",
              "task_structure": {
                "name": "string - Short name for the task",
                "description": "string - Detailed description of what needs to be done",
                "done": "boolean - false when not implemented, true when implemented"
              }
            }
          },
          "rationale": "Provides granular tracking of implementation progress with self-documenting task objects, enables clear verification of spec completion, maintains natural ordering, and keeps traceability between requirements and code",
          "when_to_use": "Propose this pattern when user creates specs that involve code implementation (files, components, APIs, features, etc.)",
          "example_spec": {
            "example-api": {
              "__meta": {
                "type": "api",
                "description": "Example REST API endpoint",
                "status": "draft"
              },
              "tasks": [
                {
                  "name": "Create handler",
                  "description": "Create endpoint handler function",
                  "done": false
                },
                {
                  "name": "Add validation",
                  "description": "Add input validation for request parameters",
                  "done": false
                },
                {
                  "name": "Write tests",
                  "description": "Write unit tests for the endpoint",
                  "done": false
                }
              ]
            }
          },
          "best_practices": [
            "Order tasks in logical sequence (implementation order)",
            "Use concise but clear names for tasks",
            "Provide detailed descriptions explaining what each task involves",
            "Set all task.done to false initially when spec is created",
            "Update task.done to true as each component is implemented",
            "Consider updating overall spec status to active when all tasks are done"
          ],
          "advantages": [
            "Natural ordering - tasks appear in implementation sequence",
            "Easy to iterate - can use array methods and jq array operations",
            "Simple indexing - access by position (tasks[0], tasks[1], etc.)",
            "Clean structure - no need for numbered keys",
            "Easy to add/remove tasks without renumbering"
          ],
          "agent_behavior": "When user requests to create a spec related to code, suggest including the tasks array pattern and offer to add task objects based on the spec requirements"
        },
        "readme-documentation": {
          "__meta": {
            "type": "documentation",
            "description": "README.md documentation for jkspec project with vision, advantages, disadvantages, and buy-me-a-coffee support button",
            "status": "active",
            "tags": [
              "documentation",
              "meta",
              "readme"
            ],
            "location": "README.md",
            "purpose": "Provide clear, honest documentation about jkspec as a prototype with potential for agent-driven development"
          },
          "sections": {
            "header": {
              "title": "jkspec",
              "tagline": "JSON-based specification format for rapid AI agent context retrieval"
            },
            "what_is_jkspec": {
              "description": "Explain what jkspec is and its core purpose",
              "content_draft": "jkspec is a single-file, JSON-based specification format designed to eliminate the context-gathering overhead AI agents face when working with codebases. Instead of agents spending time exploring directories, reading multiple files, and piecing together project structure, jkspec provides a centralized `.jkspec/source.json` file that agents can query instantly using `jq`.\n\nThink of it as a \"map\" for AI agents - a structured, queryable source of truth about your project's architecture, components, conventions, and implementation status."
            },
            "vision": {
              "description": "The vision and philosophy behind jkspec",
              "content_draft": "The vision of jkspec emerged from observing a consistent pattern: AI agents waste significant time and tokens exploring codebases before they can start actual work. Every conversation begins with \"let me look at your project structure\" followed by multiple file reads and questions.\n\njkspec flips this paradigm. What if agents could instantly access:\n- Project architecture and conventions\n- What exists and what doesn't\n- Implementation status of features\n- Dependencies and relationships\n- Historical decisions and rationale\n\nAll queryable in milliseconds with simple `jq` commands.\n\nThe broader vision is **spec-driven development with AI agents** - where specifications aren't just documentation, but active, queryable contracts that guide agent behavior and reduce ambiguity."
            },
            "prototype_notice": {
              "description": "Transparent notice that this is a prototype",
              "tone": "honest and encouraging",
              "content_draft": " **This is a prototype.** jkspec is an experiment in improving AI agent workflows. It's rough around the edges, the conventions are still evolving, and there are likely better ways to solve some of these problems.\n\nThat said, I've found it genuinely useful in my own agent-assisted development, and I believe the core idea has potential. If you're interested in exploring new ways to work with AI coding assistants, give it a try. Feedback, ideas, and constructive criticism are welcome."
            },
            "advantages": {
              "description": "Key advantages of using jkspec",
              "items": [
                {
                  "title": "Instant Context",
                  "description": "Agents get full project context in a single jq query - no exploration needed"
                },
                {
                  "title": "Single Source of Truth",
                  "description": "One file contains architecture, conventions, specs, and status - no scattered documentation"
                },
                {
                  "title": "Queryable Structure",
                  "description": "Use jq to filter by type, status, tags - agents can find exactly what they need"
                },
                {
                  "title": "Implementation Tracking",
                  "description": "Track what's draft vs active vs deprecated - clear visibility into project state"
                },
                {
                  "title": "Hierarchical Specs",
                  "description": "Nest specs arbitrarily deep to match your architecture - from high-level features down to specific validations"
                },
                {
                  "title": "Version Control Friendly",
                  "description": "JSON file diffs clearly show spec changes - easy to review and track evolution"
                },
                {
                  "title": "No External Dependencies",
                  "description": "Just JSON and jq - no special tools or frameworks required"
                },
                {
                  "title": "Agent-Optimized",
                  "description": "Designed specifically for AI agent consumption, not just human documentation"
                }
              ]
            },
            "disadvantages": {
              "description": "Honest assessment of current limitations and tradeoffs",
              "items": [
                {
                  "title": "Manual Sync Required",
                  "description": "Specs don't automatically update when code changes - requires discipline to keep in sync"
                },
                {
                  "title": "Learning Curve",
                  "description": "Requires learning jq syntax and understanding the jkspec structure conventions"
                },
                {
                  "title": "JSON Verbosity",
                  "description": "JSON can be verbose - large projects might have unwieldy source.json files"
                },
                {
                  "title": "Not Human-Optimized",
                  "description": "Reading raw JSON isn't as pleasant as markdown docs for humans (though agents don't mind)"
                },
                {
                  "title": "Prototype Limitations",
                  "description": "Conventions still evolving, tooling is minimal, edge cases not fully explored"
                },
                {
                  "title": "Single File Bottleneck",
                  "description": "All specs in one file can cause merge conflicts in team environments"
                },
                {
                  "title": "No Schema Validation Yet",
                  "description": "While a schema exists, enforcement and validation tooling is minimal"
                }
              ]
            },
            "quick_start": {
              "description": "Basic quick start instructions",
              "content_draft": "1. Clone jkspec into your project (without git history):\n   ```bash\n   npx degit jkf16m/jkspec .jkspec\n   ```\n\n2. The `.jkspec/source.json` file is your starting template - customize it:\n   - Update the `project` section with your project details\n   - **NEVER remove `__jkspec`** - it defines the jkspec framework itself\n   - Modifying `__jkspec` means modifying the framework (jkspec is self-modifiable by design)\n   - Add your own specs to the `specs` object using kebab-case keys\n\n3. Query with jq: `jq '.specs' .jkspec/source.json`\n\nFor AI agents: Point your agent to `.jkspec/source.json` and give it access to `jq`."
            },
            "core_concepts": {
              "description": "Brief explanation of core jkspec concepts",
              "concepts": [
                {
                  "name": "Specs",
                  "description": "Each spec has a `__meta` object (type, description, status, tags) plus any custom fields"
                },
                {
                  "name": "Status Lifecycle",
                  "description": "draft  active  deprecated"
                },
                {
                  "name": "Hierarchical Structure",
                  "description": "Specs can nest using keys like children, components, endpoints, tests, etc."
                },
                {
                  "name": "Internal Specs",
                  "description": "Specs prefixed with `__` are internal/meta specs that define the framework itself (like `__jkspec`). These specs should never be deleted. Modifying them means modifying the jkspec framework behavior - the framework is intentionally self-modifiable"
                },
                {
                  "name": "jq Queries",
                  "description": "Direct JSON manipulation using jq for all read/write operations"
                }
              ]
            },
            "examples": {
              "description": "Practical jq examples",
              "queries": [
                {
                  "description": "List all specs",
                  "command": "jq .specs | keys .jkspec/source.json"
                },
                {
                  "description": "Get a specific spec",
                  "command": "jq .specs[\"spec-name\"] .jkspec/source.json"
                },
                {
                  "description": "Find all draft specs",
                  "command": "jq .specs | to_entries[] | select(.value.__meta.status == \"draft\") .jkspec/source.json"
                },
                {
                  "description": "Filter by type",
                  "command": "jq .specs | to_entries[] | select(.value.__meta.type == \"api\") .jkspec/source.json"
                }
              ]
            },
            "use_cases": {
              "description": "When jkspec might be useful",
              "scenarios": [
                "Working with AI coding agents frequently",
                "Want to reduce agent context-gathering overhead",
                "Need structured, queryable project documentation",
                "Exploring spec-driven development approaches",
                "Building agent-first development workflows"
              ]
            },
            "support": {
              "description": "Buy me a coffee section at the end",
              "content_draft": "If you find jkspec useful or interesting, consider buying me a coffee! This is a personal experiment and any support helps me continue exploring ideas like this.\n\n[![Buy Me A Coffee](https://www.buymeacoffee.com/assets/img/custom_images/orange_img.png)](https://buymeacoffee.com/jdfm24)"
            }
          },
          "tasks": [
            {
              "name": "Write header and tagline",
              "description": "Create project title and compelling tagline",
              "done": true
            },
            {
              "name": "Write What is jkspec section",
              "description": "Clear explanation of what jkspec is and core purpose",
              "done": true
            },
            {
              "name": "Write Vision section",
              "description": "Explain the vision and philosophy behind jkspec",
              "done": true
            },
            {
              "name": "Write Prototype Notice",
              "description": "Honest, encouraging notice about prototype status",
              "done": true
            },
            {
              "name": "Write Advantages section",
              "description": "List key advantages with clear descriptions",
              "done": true
            },
            {
              "name": "Write Disadvantages section",
              "description": "Honest assessment of limitations and tradeoffs",
              "done": true
            },
            {
              "name": "Write Quick Start section",
              "description": "Simple getting started instructions",
              "done": true
            },
            {
              "name": "Write Core Concepts section",
              "description": "Brief explanation of key jkspec concepts",
              "done": true
            },
            {
              "name": "Write Examples section",
              "description": "Practical jq query examples",
              "done": true
            },
            {
              "name": "Write Use Cases section",
              "description": "When jkspec might be useful",
              "done": true
            },
            {
              "name": "Add Buy Me a Coffee section",
              "description": "Add support button with link at the end",
              "done": true
            },
            {
              "name": "Review and polish",
              "description": "Final review for tone, clarity, and completeness",
              "done": true
            }
          ],
          "style_guidelines": {
            "tone": "Honest, pragmatic, encouraging",
            "voice": "First-person when discussing prototype status and personal experience",
            "technical_level": "Accessible to developers familiar with JSON and basic command-line tools",
            "approach": "Lead with value proposition, be transparent about limitations, focus on practical utility"
          },
          "references": {
            "output_file": "README.md",
            "source_meta_specs": [
              "__jkspec.components.worker",
              "__jkspec.components.format",
              "__jkspec.components.depth-system",
              "__jkspec.components.traceability",
              "__jkspec.components.dual-file-architecture",
              "__jkspec.components.schema-validation"
            ],
            "update_policy": "If any referenced meta-spec status is draft, keep this spec in draft and regenerate README.md from the template before marking it active again."
          },
          "template_structure": {
            "description": "Canonical README scaffold that is regenerated whenever referenced meta-specs change",
            "section_order": [
              "header",
              "what_is_jkspec",
              "vision",
              "prototype_notice",
              "advantages",
              "disadvantages",
              "quick_start",
              "core_concepts",
              "examples",
              "use_cases",
              "support"
            ],
            "regeneration_steps": [
              "Check statuses of all source_meta_specs using jq",
              "Extract updated content from each referenced meta-spec",
              "Rewrite README sections according to this template order",
              "Review tone/style guidelines and update Buy Me a Coffee section",
              "Set readme-documentation.__meta.status back to active only after README.md has been updated"
            ],
            "validation_signal": "jkspec-validate surfaces a reminder whenever readme-documentation.__meta.status is draft, indicating README.md must be regenerated."
          }
        },
        "dual-file-architecture": {
          "__meta": {
            "type": "architecture",
            "description": "Dual-file architecture separating jkspec framework from project specifications",
            "status": "draft",
            "tags": [
              "architecture",
              "meta",
              "separation-of-concerns"
            ],
            "purpose": "Enable clean separation between jkspec framework tooling and user project specs, allowing framework updates without affecting project data",
            "complexity": "high",
            "subagent_required": true
          },
          "rationale": {
            "problem": "Currently .jkspec/source.json contains both jkspec framework specs (__jkspec) and project specs. This makes it difficult to update jkspec tooling without affecting user data.",
            "solution": "Split into two files: .jkspec/source.json (framework) and .jkspec-project/project.json (user specs). Users can update framework by cloning fresh .jkspec/ directory.",
            "benefits": [
              "Clear separation between framework and project data",
              "Users can update jkspec by deleting .jkspec/ and cloning fresh",
              "Project specs remain untouched during framework updates",
              "Transferable project.json can be shared across teams",
              "Framework and project can evolve independently"
            ]
          },
          "architecture": {
            "framework_location": {
              "path": ".jkspec/",
              "description": "Contains jkspec framework specifications and tooling",
              "files": {
                "source.json": {
                  "description": "Framework specifications including __jkspec meta specs",
                  "contains": [
                    "project metadata about jkspec itself",
                    "__jkspec spec with all framework components",
                    "worker configuration",
                    "Internal framework specs only"
                  ],
                  "modifiable": "Only when modifying the jkspec framework itself"
                },
                "jkspec.schema.json": {
                  "description": "JSON Schema used by both source.json and project.json",
                  "shared": true
                }
              }
            },
            "project_location": {
              "path": ".jkspec-project/",
              "description": "Contains user project specifications",
              "files": {
                "project.json": {
                  "description": "User project specifications",
                  "schema": "Uses .jkspec/jkspec.schema.json",
                  "contains": [
                    "project metadata for the user's actual project",
                    "User-defined specs (no __ prefix)",
                    "Project-specific conventions and decisions",
                    "All user spec data"
                  ],
                  "transferable": true,
                  "modifiable": "Users freely modify this for their project"
                }
              },
              "note": "Not created in jkspec repo - only in user projects"
            }
          },
          "schema_usage": {
            "description": "Both files use the same jkspec.schema.json for validation",
            "framework_file": ".jkspec/source.json validates against .jkspec/jkspec.schema.json",
            "project_file": ".jkspec-project/project.json validates against .jkspec/jkspec.schema.json",
            "shared_structure": {
              "project": "Both files have project object with different metadata",
              "specs": "Both files have specs object with different content",
              "worker": ".jkspec/source.json contains worker config, .jkspec-project/project.json does not need it"
            }
          },
          "agent_behavior": {
            "initialization": {
              "description": "How agents should initialize and discover spec files",
              "discovery_order": [
                "1. Check if .jkspec-project/ directory exists",
                "2. If not exists, create .jkspec-project/ directory",
                "3. Check if .jkspec-project/project.json exists",
                "4. If not exists, create project.json with minimal template",
                "5. Always read .jkspec/source.json for framework specs and worker config",
                "6. Always read .jkspec-project/project.json for user project specs"
              ]
            },
            "bootstrap_modification": {
              "description": "Worker bootstrap needs to check for project file existence",
              "location": "Update worker.bootstrap or add to worker guidelines",
              "new_checks": [
                "Check .jkspec-project/ existence before any operations",
                "Auto-create .jkspec-project/project.json if missing",
                "Inform user when creating new project file"
              ]
            },
            "query_strategy": {
              "framework_queries": "Use .jkspec/source.json for framework and worker info",
              "project_queries": "Use .jkspec-project/project.json for user project specs",
              "combined_view": "Agents may need to query both files for complete context"
            }
          },
          "migration": {
            "description": "How to migrate existing projects from single-file to dual-file",
            "from_current_structure": {
              "step_1": "Identify user specs (non-__ prefix) in current .jkspec/source.json",
              "step_2": "Create .jkspec-project/ directory",
              "step_3": "Create project.json with project metadata and user specs only",
              "step_4": "Remove user specs from .jkspec/source.json, keep only __jkspec and framework specs",
              "step_5": "Update .jkspec/source.json project metadata to describe jkspec framework itself",
              "step_6": "Test agent queries against both files"
            }
          },
          "project_json_template": {
            "description": "Minimal template for new .jkspec-project/project.json",
            "template": {
              "project": {
                "name": "your-project-name",
                "description": "Your project description",
                "version": "0.1.0",
                "architecture": {
                  "style": "Define your architecture style",
                  "pattern": "Define your patterns"
                },
                "conventions": {
                  "spec_location": ".jkspec-project/project.json"
                },
                "decisions": []
              },
              "specs": {}
            }
          },
          "worker_integration": {
            "description": "How worker commands should integrate with dual-file architecture",
            "command_modifications": {
              "jkspec-extend": "Should add user specs to .jkspec-project/project.json, not source.json",
              "jkspec-update": "Should determine which file to update based on spec prefix (__ = source.json, else = project.json)",
              "jkspec-validate": "Should validate both files",
              "jkspec-analyze": "Should analyze both files and report on each",
              "jkspec-suggest-specs": "Should suggest specs for project.json",
              "jkspec-test-sync": "Should check implementations for specs in project.json",
              "jkspec-implement": "Should work with specs from project.json",
              "jkspec-explain": "Should explain specs from either file",
              "jkspec-verify": "Should verify implementations from project.json"
            },
            "file_selection_logic": {
              "rule_1": "If spec-id starts with __, use .jkspec/source.json (framework)",
              "rule_2": "If spec-id does NOT start with __, use .jkspec-project/project.json (user project)",
              "rule_3": "Worker config always read from .jkspec/source.json",
              "rule_4": "Project specs always read from .jkspec-project/project.json"
            }
          },
          "tasks": [
            {
              "name": "Update worker bootstrap guidelines",
              "description": "Add project file discovery to worker.guidelines so agents know to check for .jkspec-project/project.json",
              "done": false
            },
            {
              "name": "Add schema validation spec",
              "description": "Add or update spec documenting that validation uses ajv for both source.json and project.json",
              "done": false
            },
            {
              "name": "Create dual-file architecture tests",
              "description": "Create tests in .jkspec/tests/ to verify agent behavior with dual-file setup",
              "done": false
            },
            {
              "name": "Update worker commands documentation",
              "description": "Update command markdown files to document file selection logic (__ prefix = source.json, no prefix = project.json)",
              "done": false
            },
            {
              "name": "Update README with dual-file explanation",
              "description": "Document in README that users get project.json auto-created in their projects",
              "done": false
            }
          ],
          "implementation_note": "This is a meta-spec only. The .jkspec-project/ directory and project.json file are NOT created in the jkspec repository itself. They are auto-created by agents when users use jkspec in their own projects.",
          "test_scenarios": {
            "description": "Test scenarios to verify dual-file architecture behavior",
            "test_location": ".jkspec/tests/dual-file-architecture/",
            "scenarios": {
              "project_json_discovery": {
                "description": "Test that agents properly discover or create project.json",
                "setup": "Temporary directory with .jkspec/ but no .jkspec-project/",
                "expected": "Agent creates .jkspec-project/project.json with minimal template",
                "test_file": "test_project_discovery.js"
              },
              "file_selection_by_prefix": {
                "description": "Test that __ prefix specs route to source.json, others to project.json",
                "setup": "Both source.json and project.json exist",
                "operations": [
                  "Query __jkspec spec - should read from source.json",
                  "Query user-spec (no __) - should read from project.json",
                  "Add spec with __ prefix - should write to source.json",
                  "Add spec without __ prefix - should write to project.json"
                ],
                "test_file": "test_file_selection.js"
              },
              "schema_validation_both_files": {
                "description": "Test that validation validates both files",
                "setup": "Both source.json and project.json with valid specs",
                "expected": "Both files pass ajv validation against jkspec.schema.json",
                "test_file": "test_schema_validation.js"
              },
              "project_json_required": {
                "description": "Test that operations BLOCK until project.json exists (create it automatically if missing)",
                "setup": "Only .jkspec/source.json exists",
                "expected": ".jkspec-project/project.json is auto-created before accepting user specs",
                "test_file": "test_project_required.js"
              },
              "migration_scenario": {
                "description": "Test migration from single-file to dual-file",
                "setup": "Old source.json with both __ and user specs",
                "operation": "Run migration to split into source.json and project.json",
                "expected": "__ specs remain in source.json, user specs move to project.json",
                "test_file": "test_migration.js"
              }
            }
          },
          "schema_handling": {
            "description": "How schema files are handled in dual-file architecture",
            "schema_location": ".jkspec/jkspec.schema.json",
            "shared_schema": "Both source.json and project.json validate against the same schema file",
            "user_projects": {
              "option_1": {
                "approach": "Reference schema from .jkspec/ directory",
                "validation_path": ".jkspec/jkspec.schema.json",
                "note": "Schema is part of framework, gets updated with framework updates"
              },
              "option_2": {
                "approach": "Copy schema to .jkspec-project/ directory",
                "validation_path": ".jkspec-project/jkspec.schema.json",
                "note": "Allows offline validation, but needs manual sync with framework updates"
              },
              "recommended": "option_1 - Keep schema in .jkspec/ as single source of truth"
            },
            "validation_command": "Validation should always reference .jkspec/jkspec.schema.json regardless of which file is being validated"
          }
        },
        "schema-validation": {
          "__meta": {
            "type": "validation",
            "description": "JSON Schema validation for jkspec files using ajv",
            "status": "draft",
            "tags": [
              "validation",
              "schema",
              "ajv"
            ],
            "purpose": "Define validation strategy for both source.json and project.json files"
          },
          "validator": {
            "tool": "ajv",
            "description": "AJV (Another JSON Schema Validator) - fast JSON schema validator",
            "package": "ajv",
            "why_ajv": "Industry-standard, performant, supports JSON Schema draft 2020-12"
          },
          "files_to_validate": {
            "framework_file": {
              "path": ".jkspec/source.json",
              "schema": ".jkspec/jkspec.schema.json",
              "description": "Framework specifications including __jkspec meta specs"
            },
            "project_file": {
              "path": ".jkspec-project/project.json",
              "schema": ".jkspec/jkspec.schema.json",
              "description": "User project specifications (file MUST exist; create it before any user spec work)",
              "optional": false
            }
          },
          "validation_rules": {
            "required_fields": [
              "All specs must have __meta with type, description, status",
              "Root must have project and specs objects"
            ],
            "spec_id_format": "Must use kebab-case (lowercase with hyphens)",
            "status_values": [
              "draft",
              "active",
              "deprecated"
            ],
            "internal_specs": "Specs with __ prefix should only exist in source.json"
          },
          "validation_command": {
            "description": "jkspec-validate command validates both files",
            "behavior": [
              "Validate .jkspec/source.json against schema",
              "Check if .jkspec-project/project.json exists",
              "If exists, validate .jkspec-project/project.json against schema",
              "Report validation results for both files"
            ]
          },
          "tasks": [
            {
              "name": "Install ajv dependency",
              "description": "Add ajv package for JSON schema validation",
              "done": false
            },
            {
              "name": "Create validation script",
              "description": "Create validation script that uses ajv to validate both files",
              "done": false
            },
            {
              "name": "Integrate with jkspec-validate command",
              "description": "Update jkspec-validate command to use ajv validation",
              "done": false
            },
            {
              "name": "Add validation tests",
              "description": "Create tests for schema validation with valid and invalid specs",
              "done": false
            }
          ]
        }
      }
    }
  }
}
