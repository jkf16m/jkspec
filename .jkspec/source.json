{
  "project": {
    "name": "jkspec",
    "description": "JSON-based specification format for rapid AI agent context retrieval. Provides jkspec-template as a starter template for projects.",
    "version": "0.1.0",
    "architecture": {
      "style": "single-file specification",
      "pattern": "spec-driven development",
      "philosophy": "Provide AI agents with structured, queryable context to eliminate codebase exploration overhead"
    },
    "conventions": {
      "spec_location": ".jkspec/source.json",
      "query_tool": "jq",
      "spec_keys": "Use kebab-case for spec identifiers (e.g., 'auth-service', 'user-model')",
      "internal_specs": "Specs prefixed with __ are internal/meta specs (e.g., '__jkspec')",
      "versioning": "Semantic versioning for the spec format itself"
    },
    "decisions": [
      {
        "id": "ADR-001",
        "title": "Use single JSON file as source of truth",
        "status": "accepted",
        "date": "2025-12-25",
        "context": "AI agents waste time exploring codebases. Need fast, precise context retrieval.",
        "decision": "Use single .jkspec/source.json file with structured data, queryable via jq",
        "consequences": "Agents get instant context. Must maintain spec alongside code. JSON parsing overhead minimal."
      },
      {
        "id": "ADR-002",
        "title": "Use object for specs instead of array",
        "status": "accepted",
        "date": "2025-12-25",
        "context": "Need to avoid duplicate keys and enable direct access",
        "decision": "Use object with unique keys for specs: {\"spec-name\": {...}}",
        "consequences": "Direct access via jq '.specs[\"name\"]'. Natural key uniqueness. Slightly more verbose queries for filtering."
      },
      {
        "id": "ADR-003",
        "title": "Use __ prefix for internal specs",
        "status": "accepted",
        "date": "2025-12-25",
        "context": "Need to distinguish internal jkspec infrastructure from user specs",
        "decision": "Prefix internal/meta specs with __ (double underscore) to clearly mark them as part of jkspec itself",
        "consequences": "Users can easily identify and avoid modifying internal specs. Clear separation of concerns between framework and user content."
      }
    ]
  },
  "specs": {
    "__jkspec": {
      "type": "meta",
      "description": "Internal jkspec system specification - contains all jkspec infrastructure components",
      "status": "active",
      "tags": [
        "internal",
        "meta",
        "jkspec-system"
      ],
      "note": "This is an internal spec. User specs should not use the __ prefix.",
      "components": {
        "format": {
          "type": "specification",
          "description": "The jkspec format itself - structure and conventions",
          "status": "active",
          "tags": [
            "meta",
            "format"
          ],
          "structure": {
            "project": {
              "name": "string - project name",
              "description": "string - brief project description",
              "version": "string - semver",
              "architecture": "object - architectural overview",
              "conventions": "object - global coding and organizational conventions",
              "decisions": "array - architectural decision records"
            },
            "specs": {
              "description": "object - keyed by unique spec identifier",
              "spec_schema": {
                "type": "string - spec type (api, model, component, etc.)",
                "description": "string - what this spec describes",
                "status": "string - draft, active, deprecated",
                "tags": "array - searchable tags",
                "...": "any additional fields relevant to the spec"
              }
            }
          },
          "examples": {
            "get_project_info": "jq '.project' .jkspec/source.json",
            "list_all_specs": "jq '.specs | keys' .jkspec/source.json",
            "get_specific_spec": "jq '.specs[\"spec-name\"]' .jkspec/source.json",
            "filter_by_type": "jq '.specs | to_entries[] | select(.value.type==\"api\")' .jkspec/source.json",
            "filter_by_tag": "jq '.specs | to_entries[] | select(.value.tags[]? == \"authentication\")' .jkspec/source.json"
          },
          "location": ".jkspec/source.json",
          "hierarchical_specifications": {
            "description": "Specs can contain nested child specifications at any depth using arbitrary keys",
            "common_keys": [
              "children",
              "specs",
              "tests",
              "endpoints",
              "components",
              "requirements"
            ],
            "status_lifecycle": {
              "draft": "Specification not yet implemented",
              "active": "Specification fully implemented and working",
              "deprecated": "Specification no longer in use"
            },
            "auto_draft_rule": "ANY modification to a spec (except direct status changes) automatically sets status to 'draft'. Modifying child specs also sets parent to 'draft'.",
            "philosophy": "Instead of redoing implementations, refine specs by adding more detailed child specifications to achieve more accurate results"
          },
          "nested_examples": {
            "simple_nesting": {
              "parent_spec": "__jkspec",
              "child_key": "components",
              "children": {
                "format": {
                  "type": "specification",
                  "description": "The jkspec format specification",
                  "status": "active"
                }
              }
            },
            "deep_nesting": {
              "description": "Specs can nest arbitrarily deep",
              "example": "auth-api > endpoints > login > validations > email-format"
            }
          },
          "cli_commands_for_nesting": {
            "add_child": "./jkspec add-child <parent-id> <child-key> <child-id> <type> <description> [tags...]",
            "update_child": "./jkspec update-child <parent-id> <child-key> <child-id> <field> <value>",
            "get_child": "./jkspec get-child <parent-id> <child-key> <child-id>"
          }
        },
        "cli": {
          "type": "tool",
          "description": "Bash CLI tool for managing .jkspec/source.json files",
          "status": "active",
          "tags": [
            "cli",
            "tooling",
            "bash"
          ],
          "location": ".jkspec/cli/jkspec.sh",
          "dependencies": [
            "jq"
          ],
          "commands": {
            "init": "Initialize a new jkspec project",
            "add-spec": "Add a new spec with ID, type, description, and tags",
            "update-spec": "Update a field in an existing spec",
            "remove-spec": "Remove a spec by ID",
            "list": "List all spec IDs",
            "get": "Get a specific spec by ID",
            "help": "Show usage information"
          },
          "purpose": "Provide a human-friendly CLI interface for creating and managing jkspec files without manual JSON editing"
        },
        "depth-system": {
          "type": "feature",
          "description": "Single unified agent architecture where jkspec-worker handles all operations from high-level management to detailed implementation",
          "status": "active",
          "tags": [
            "architecture",
            "unified-agent"
          ],
          "purpose": "Simplified architecture with one agent that can handle any jkspec task",
          "concepts": {
            "spec_levels": {
              "simple": "Single file, small component, or focused investigation",
              "medium": "Module, service, or feature with multiple files",
              "complex": "System, architecture, or large-scale feature spanning multiple modules"
            },
            "unified_approach": "Single agent handles both management operations (add/update/validate specs) and implementation work (read/implement/verify specs)"
          },
          "agent_responsibilities": {
            "jkspec-worker": "Handles ALL operations: extends specs, validates structure, analyzes codebase, implements features, explains specs, and verifies implementations"
          },
          "location": ".opencode/agent/",
          "implemented_in": [
            ".opencode/agent/jkspec-worker.md"
          ]
        },
        "worker": {
          "type": "agent",
          "description": "Unified agent for managing and implementing jkspec specifications - handles both high-level management operations and detailed implementation work",
          "status": "active",
          "tags": [
            "ai-agents",
            "management",
            "implementation"
          ],
          "purpose": "Single agent that can extend, validate, maintain jkspec files AND read/implement individual specs",
          "capabilities": {
            "management": [
              "Add new specs (extend command)",
              "Update existing specs (update command)",
              "Validate jspec structure (validate command)",
              "Analyze specs and provide recommendations (analyze command)",
              "Suggest missing specs (suggest-specs command)",
              "Verify implementation status (test-sync command)"
            ],
            "implementation": [
              "Read and explain spec details (explain command)",
              "Implement specs according to requirements (implement command)",
              "Verify implementations match specs (verify command)",
              "Work with complex multi-component specs"
            ]
          },
          "commands": {
            "extend": "Add a new spec to the jspec file",
            "update": "Update an existing spec field",
            "validate": "Validate the jspec structure and check for inconsistencies",
            "analyze": "Analyze the current jkspec structure and provide recommendations",
            "suggest-specs": "Suggest missing specs based on codebase analysis",
            "test-sync": "Verify that all specs have corresponding implementations",
            "implement": "Implement a spec according to its requirements",
            "explain": "Read and explain a specific spec's details",
            "verify": "Verify if a spec is implemented correctly"
          },
          "location": ".opencode/agent/jkspec-worker.md",
          "dependencies": [
            "jkspec-cli"
          ],
          "tool_resolution": "dynamic",
          "reading_policy": "MANDATORY: Always use jkspec-cli tool for reading specs. Use '.jkspec/cli/jkspec.sh get <spec-id>' instead of jq queries. This ensures consistent access patterns and proper tool usage."
        },
        "template": {
          "type": "template",
          "description": "Starter template for new jkspec projects",
          "status": "active",
          "tags": [
            "template",
            "setup"
          ],
          "location": "jkspec-template/",
          "contents": {
            "source_json": ".jkspec/source.json with minimal project structure",
            "jkspec_symlink": "Symlink to parent jkspec CLI tool"
          }
        },

        "traceability": {
          "type": "meta-guideline",
          "description": "Guideline for creating traceable specs with implementation status tracking using task arrays",
          "status": "active",
          "tags": [
            "meta",
            "guideline",
            "traceability"
          ],
          "purpose": "Define a standardized pattern for tracking implementation tasks within specs to ensure clear traceability between specification and actual code",
          "concept": "When creating code-related specs, include a tasks array where each element is a task object containing name, description, and done status",
          "pattern": {
            "tasks": {
              "description": "Array of task objects",
              "task_structure": {
                "name": "string - Short name for the task",
                "description": "string - Detailed description of what needs to be done",
                "done": "boolean - false when not implemented, true when implemented"
              }
            }
          },
          "rationale": "Provides granular tracking of implementation progress with self-documenting task objects, enables clear verification of spec completion, maintains natural ordering, and keeps traceability between requirements and code",
          "when_to_use": "Propose this pattern when user creates specs that involve code implementation (files, components, APIs, features, etc.)",
          "example_spec": {
            "example-api": {
              "type": "api",
              "description": "Example REST API endpoint",
              "status": "draft",
              "tasks": [
                {
                  "name": "Create handler",
                  "description": "Create endpoint handler function",
                  "done": false
                },
                {
                  "name": "Add validation",
                  "description": "Add input validation for request parameters",
                  "done": false
                },
                {
                  "name": "Write tests",
                  "description": "Write unit tests for the endpoint",
                  "done": false
                }
              ]
            }
          },
          "best_practices": [
            "Order tasks in logical sequence (implementation order)",
            "Use concise but clear names for tasks",
            "Provide detailed descriptions explaining what each task involves",
            "Set all task.done to false initially when spec is created",
            "Update task.done to true as each component is implemented",
            "Consider updating overall spec status to active when all tasks are done"
          ],
          "advantages": [
            "Natural ordering - tasks appear in implementation sequence",
            "Easy to iterate - can use array methods and jq array operations",
            "Simple indexing - access by position (tasks[0], tasks[1], etc.)",
            "Clean structure - no need for numbered keys",
            "Easy to add/remove tasks without renumbering"
          ],
          "agent_behavior": "When user requests to create a spec related to code, suggest including the tasks array pattern and offer to add task objects based on the spec requirements"
        }
      }
    }
  },
  "worker": {
    "bootstrap": {
      "first_command": "jq '.worker' .jkspec/source.json",
      "description": "On initialization, agent must read the worker object which contains all operational definitions",
      "cli_fetch": "JKSPEC_CLI=$(jq -r '.specs[\"__jkspec\"].components.cli.location' .jkspec/source.json)"
    },
    "commands_location": ".opencode/commands",
    "commands_description": "All jkspec-worker commands are defined as individual markdown files in .opencode/commands/ directory. Each command file contains description, steps, and additional context.",
    "available_commands": [
      "jkspec-extend",
      "jkspec-update",
      "jkspec-validate",
      "jkspec-analyze",
      "jkspec-suggest-specs",
      "jkspec-test-sync",
      "jkspec-implement",
      "jkspec-explain",
      "jkspec-verify"
    ],
    "reading_policy": {
      "cli_mandatory": true,
      "bootstrap_exceptions": [
        "Fetching CLI location from specs",
        "Reading worker object itself",
        "Reading project metadata"
      ],
      "allowed_direct_queries": [
        "jq -r '.specs[\"__jkspec\"].components.cli.location' .jkspec/source.json",
        "jq '.worker' .jkspec/source.json",
        "jq '.project' .jkspec/source.json"
      ],
      "mandatory_cli_usage": [
        "$JKSPEC_CLI get <spec-id> - for reading any spec",
        "$JKSPEC_CLI list - for listing all spec IDs",
        "$JKSPEC_CLI add-spec - for adding specs",
        "$JKSPEC_CLI update-spec - for updating specs",
        "$JKSPEC_CLI remove-spec - for removing specs"
      ],
      "rationale": "Ensures consistent access patterns, proper tool usage validation, and single source of truth for spec retrieval"
    },
    "guidelines": [
      "Always validate input - check spec-id naming conventions and required fields",
      "Fetch tool locations dynamically from source.json",
      "Use jkspec CLI for all spec modifications",
      "Use CLI for reading specs (except bootstrap cases)",
      "Be concise and provide clear, actionable output",
      "Show results after operations",
      "Handle errors gracefully with explanations",
      "Follow kebab-case convention for spec IDs",
      "Be autonomous within spec scope",
      "Ensure thorough implementation according to requirements"
    ],
    "complex_specs": {
      "description": "How to handle specs with multiple components",
      "approach": [
        "Identify child specs (look for children, specs, tests fields)",
        "Break down work into components",
        "Implement systematically through each component",
        "Track progress and update status fields",
        "Report comprehensively on all components"
      ]
    }
  }
}
