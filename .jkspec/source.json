{
  "project": {
    "name": "jkspec",
    "description": "JSON-based specification format for rapid AI agent context retrieval. Provides jkspec-template as a starter template for projects.",
    "version": "0.1.0",
    "architecture": {
      "style": "single-file specification",
      "pattern": "spec-driven development",
      "philosophy": "Provide AI agents with structured, queryable context to eliminate codebase exploration overhead"
    },
    "conventions": {
      "spec_location": ".jkspec/source.json",
      "query_tool": "jq",
      "spec_keys": "Use kebab-case for spec identifiers (e.g., 'auth-service', 'user-model')",
      "internal_specs": "Specs prefixed with __ are internal/meta specs (e.g., '__jkspec')",
      "versioning": "Semantic versioning for the spec format itself",
      "dual_file_architecture": "Framework specs in .jkspec/source.json, project specs in .jkspec-project/project.json",
      "schema_validation": "Both files validate against .jkspec/jkspec.schema.json using ajv"
    },
    "decisions": [
      {
        "id": "ADR-001",
        "title": "Use single JSON file as source of truth",
        "status": "accepted",
        "date": "2025-12-25",
        "context": "AI agents waste time exploring codebases. Need fast, precise context retrieval.",
        "decision": "Use single .jkspec/source.json file with structured data, queryable via jq",
        "consequences": "Agents get instant context. Must maintain spec alongside code. JSON parsing overhead minimal."
      },
      {
        "id": "ADR-002",
        "title": "Use object for specs instead of array",
        "status": "accepted",
        "date": "2025-12-25",
        "context": "Need to avoid duplicate keys and enable direct access",
        "decision": "Use object with unique keys for specs: {\"spec-name\": {...}}",
        "consequences": "Direct access via jq '.specs[\"name\"]'. Natural key uniqueness. Slightly more verbose queries for filtering."
      },
      {
        "id": "ADR-003",
        "title": "Use __ prefix for internal specs",
        "status": "accepted",
        "date": "2025-12-25",
        "context": "Need to distinguish internal jkspec infrastructure from user specs",
        "decision": "Prefix internal/meta specs with __ (double underscore) to clearly mark them as part of jkspec itself",
        "consequences": "Users can easily identify and avoid modifying internal specs. Clear separation of concerns between framework and user content."
      },
      {
        "id": "ADR-004",
        "title": "Remove CLI abstraction, use jq directly",
        "status": "accepted",
        "date": "2025-12-25",
        "context": "CLI tool adds complexity and maintenance burden. AI agents are fluent in jq. Direct manipulation is more transparent.",
        "decision": "Remove jkspec CLI tool. Use jq directly for all read/write operations on .jkspec/source.json",
        "consequences": "Simpler architecture with fewer moving parts. Agent can see exact jq commands. Users learn standard jq instead of custom CLI. Slightly more verbose operations but more transparent and flexible."
      },
      {
        "id": "ADR-005",
        "title": "Separate jkspec framework from project specifications using dual-file architecture",
        "status": "accepted",
        "date": "2025-12-25",
        "context": "Users need to update jkspec tooling without affecting their project data. Currently .jkspec/source.json mixes framework specs (__jkspec) with project specs, making updates risky and cumbersome.",
        "decision": "Split into two files: .jkspec/source.json (framework only with __jkspec specs) and .jkspec-project/project.json (user project specs). Both use the same schema. Agents check for .jkspec-project/ on init and create if missing.",
        "consequences": "Users can update jkspec by deleting .jkspec/ and cloning fresh. Project data in .jkspec-project/project.json remains safe. Commands must implement file selection logic based on spec-id prefix. Slightly more complex for agents but much cleaner separation of concerns."
      }
    ]
  },
  "specs": {
    "__jkspec": {
      "__meta": {
        "type": "meta",
        "description": "Internal jkspec system specification - contains all jkspec infrastructure components",
        "status": "active",
        "tags": [
          "internal",
          "meta",
          "jkspec-system"
        ],
        "note": "This is an internal spec. User specs should not use the __ prefix."
      },
      "components": {
        "format": {
          "__meta": {
            "type": "specification",
            "description": "The jkspec format itself - structure and conventions",
            "status": "active",
            "tags": [
              "meta",
              "format"
            ],
            "location": ".jkspec/source.json"
          },
          "structure": {
            "project": {
              "name": "string - project name",
              "description": "string - brief project description",
              "version": "string - semver",
              "architecture": "object - architectural overview",
              "conventions": "object - global coding and organizational conventions",
              "decisions": "array - architectural decision records"
            },
            "specs": {
              "description": "object - keyed by unique spec identifier",
              "spec_schema": {
                "__meta": {
                  "core_fields": {
                    "type": "string - spec type (api, model, component, feature, etc.)",
                    "description": "string - what this spec describes",
                    "status": "string - draft, active, deprecated",
                    "tags": "array - searchable tags for filtering and categorization"
                  },
                  "optional_fields": {
                    "location": "string - file path or directory where this spec is implemented",
                    "purpose": "string - why this spec exists or what problem it solves",
                    "dependencies": "array - list of dependencies (packages, libraries, other specs)",
                    "note": "string - additional notes or warnings about this spec",
                    "complexity": "string - low, medium, high - indicates implementation complexity",
                    "subagent_required": "boolean - true if spec is complex enough to warrant spawning a dedicated subagent for implementation"
                  },
                  "description": "All specs must have a __meta object with at minimum the core fields. Optional fields provide additional context and control."
                },
                "...": "any additional fields relevant to the spec"
              }
            }
          },
          "examples": {
            "get_project_info": "jq \".project\" .jkspec/source.json",
            "list_all_specs": "jq \".specs | keys\" .jkspec/source.json",
            "get_specific_spec": "jq \".specs[\\\"spec-name\\\"]\" .jkspec/source.json",
            "get_spec_meta": "jq \".specs[\\\"spec-name\\\"].__meta\" .jkspec/source.json",
            "filter_by_type": "jq \".specs | to_entries[] | select(.value.__meta.type==\\\"api\\\")\" .jkspec/source.json",
            "filter_by_tag": "jq \".specs | to_entries[] | select(.value.__meta.tags[]? == \\\"authentication\\\")\" .jkspec/source.json",
            "filter_by_status": "jq \".specs | to_entries[] | select(.value.__meta.status == \\\"draft\\\")\" .jkspec/source.json"
          },
          "hierarchical_specifications": {
            "description": "Specs can contain nested child specifications at any depth using arbitrary keys",
            "common_keys": [
              "children",
              "specs",
              "tests",
              "endpoints",
              "components",
              "requirements"
            ],
            "status_lifecycle": {
              "draft": "Specification not yet implemented",
              "active": "Specification fully implemented and working",
              "deprecated": "Specification no longer in use"
            },
            "auto_draft_rule": "ANY modification to a spec (except direct status changes) automatically sets status to 'draft'. Modifying child specs also sets parent to 'draft'.",
            "philosophy": "Instead of redoing implementations, refine specs by adding more detailed child specifications to achieve more accurate results"
          },
          "nested_examples": {
            "simple_nesting": {
              "parent_spec": "__jkspec",
              "child_key": "components",
              "children": {
                "format": {
                  "__meta": {
                    "type": "specification",
                    "description": "The jkspec format specification",
                    "status": "active"
                  }
                }
              }
            },
            "deep_nesting": {
              "description": "Specs can nest arbitrarily deep with each level having its own __meta",
              "example": "auth-api > endpoints > login > validations > email-format",
              "structure": {
                "auth-api": {
                  "__meta": {
                    "type": "api",
                    "description": "Authentication API",
                    "status": "active"
                  },
                  "endpoints": {
                    "login": {
                      "__meta": {
                        "type": "endpoint",
                        "description": "Login endpoint",
                        "status": "active"
                      },
                      "validations": {
                        "email-format": {
                          "__meta": {
                            "type": "validation",
                            "description": "Email format validation",
                            "status": "active"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "jq_editing_examples": {
            "add_new_spec": "jq \".specs[\\\"new-spec-id\\\"] = {__meta: {type: \\\"component\\\", description: \\\"New component\\\", status: \\\"draft\\\", tags: [\\\"frontend\\\"]}}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "update_meta_field": "jq \".specs[\\\"spec-id\\\"].__meta.status = \\\"active\\\"\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "remove_spec": "jq \"del(.specs[\\\"spec-id\\\"])\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "add_nested_child": "jq \".specs[\\\"parent-id\\\"].children[\\\"child-id\\\"] = {__meta: {type: \\\"subcomponent\\\", description: \\\"Child spec\\\", status: \\\"draft\\\"}}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "update_nested_meta": "jq \".specs[\\\"parent-id\\\"].children[\\\"child-id\\\"].__meta.status = \\\"active\\\"\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "add_tag": "jq \".specs[\\\"spec-id\\\"].__meta.tags += [\\\"new-tag\\\"]\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "remove_tag": "jq \".specs[\\\"spec-id\\\"].__meta.tags -= [\\\"old-tag\\\"]\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "add_task": "jq \".specs[\\\"spec-id\\\"].tasks += [{name: \\\"Task name\\\", description: \\\"Task description\\\", done: false}]\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "mark_task_done": "jq \".specs[\\\"spec-id\\\"].tasks[0].done = true\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "update_multiple_meta": "jq \".specs[\\\"spec-id\\\"].__meta |= . + {status: \\\"active\\\", location: \\\"path/to/file\\\"}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "add_data_field": "jq \".specs[\\\"spec-id\\\"].custom_data = {key: \\\"value\\\"}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json"
          }
        },
        "depth-system": {
          "__meta": {
            "type": "feature",
            "description": "Single unified agent architecture where jkspec-worker handles all operations from high-level management to detailed implementation",
            "status": "active",
            "tags": [
              "architecture",
              "unified-agent"
            ],
            "purpose": "Simplified architecture with one agent that can handle any jkspec task",
            "location": ".opencode/agent/"
          },
          "concepts": {
            "spec_levels": {
              "simple": "Single file, small component, or focused investigation",
              "medium": "Module, service, or feature with multiple files",
              "complex": "System, architecture, or large-scale feature spanning multiple modules"
            },
            "unified_approach": "Single agent handles both management operations (add/update/validate specs) and implementation work (read/implement/verify specs)"
          },
          "agent_responsibilities": {
            "jkspec-worker": "Handles ALL operations: extends specs, validates structure, analyzes codebase, implements features, explains specs, and verifies implementations"
          },
          "implemented_in": [
            ".opencode/agent/jkspec-worker.md"
          ]
        },
        "worker": {
          "__meta": {
            "type": "agent",
            "description": "Unified agent for managing and implementing jkspec specifications - handles both high-level management operations and detailed implementation work",
            "status": "active",
            "tags": [
              "ai-agents",
              "management",
              "implementation"
            ],
            "purpose": "Single agent that can extend, validate, maintain jkspec files AND read/implement individual specs using jq directly",
            "location": ".opencode/agent/jkspec-worker.md",
            "dependencies": [
              "jq"
            ]
          },
          "capabilities": {
            "management": [
              "Add new specs (extend command)",
              "Update existing specs (update command)",
              "Validate jspec structure (validate command)",
              "Analyze specs and provide recommendations (analyze command)",
              "Suggest missing specs (suggest-specs command)",
              "Verify implementation status (test-sync command)"
            ],
            "implementation": [
              "Read and explain spec details (explain command)",
              "Implement specs according to requirements (implement command)",
              "Verify implementations match specs (verify command)",
              "Work with complex multi-component specs"
            ]
          },
          "commands": {
            "extend": "Add a new spec to the jspec file",
            "update": "Update an existing spec field",
            "validate": "Validate the jspec structure and check for inconsistencies",
            "analyze": "Analyze the current jkspec structure and provide recommendations",
            "suggest-specs": "Suggest missing specs based on codebase analysis",
            "test-sync": "Verify that all specs have corresponding implementations",
            "implement": "Implement a spec according to its requirements",
            "explain": "Read and explain a specific spec's details",
            "verify": "Verify if a spec is implemented correctly"
          },
          "jq_operations": {
            "reading": {
              "get_spec": "jq \".specs[\\\"spec-id\\\"]\" .jkspec/source.json",
              "get_spec_meta": "jq \".specs[\\\"spec-id\\\"].__meta\" .jkspec/source.json",
              "get_nested_spec": "jq \".specs[\\\"parent-id\\\"].children[\\\"child-id\\\"]\" .jkspec/source.json",
              "get_nested_meta": "jq \".specs[\\\"parent-id\\\"].children[\\\"child-id\\\"].__meta\" .jkspec/source.json",
              "list_all_specs": "jq \".specs | keys\" .jkspec/source.json",
              "list_specs_by_type": "jq \".specs | to_entries[] | select(.value.__meta.type == \\\"api\\\") | .key\" .jkspec/source.json",
              "list_specs_by_tag": "jq \".specs | to_entries[] | select(.value.__meta.tags[]? == \\\"backend\\\") | .key\" .jkspec/source.json",
              "get_all_draft_specs": "jq \".specs | to_entries[] | select(.value.__meta.status == \\\"draft\\\")\" .jkspec/source.json",
              "get_project_info": "jq \".project\" .jkspec/source.json"
            },
            "writing": {
              "add_spec": "jq \".specs[\\\"new-spec\\\"] = {__meta: {type: \\\"component\\\", description: \\\"Description\\\", status: \\\"draft\\\", tags: []}}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "update_meta_field": "jq \".specs[\\\"spec-id\\\"].__meta.status = \\\"active\\\"\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "add_data_field": "jq \".specs[\\\"spec-id\\\"].new_field = \\\"value\\\"\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "add_nested_spec": "jq \".specs[\\\"parent\\\"].children[\\\"child\\\"] = {__meta: {type: \\\"type\\\", description: \\\"desc\\\", status: \\\"draft\\\"}}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "add_tag": "jq \".specs[\\\"spec-id\\\"].__meta.tags += [\\\"new-tag\\\"]\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "update_multiple_meta": "jq \".specs[\\\"spec-id\\\"].__meta |= . + {status: \\\"active\\\", location: \\\"path/to/file\\\"}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json"
            },
            "deleting": {
              "remove_spec": "jq \"del(.specs[\\\"spec-id\\\"])\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "remove_nested": "jq \"del(.specs[\\\"parent\\\"].children[\\\"child\\\"])\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "remove_data_field": "jq \"del(.specs[\\\"spec-id\\\"].field_name)\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "remove_tag": "jq \".specs[\\\"spec-id\\\"].__meta.tags -= [\\\"tag-to-remove\\\"]\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "remove_meta_field": "jq \"del(.specs[\\\"spec-id\\\"].__meta.field_name)\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json"
            },
            "advanced": {
              "conditional_update": "jq \".specs |= with_entries(if .value.__meta.status == \\\"draft\\\" then .value.__meta.status = \\\"reviewed\\\" else . end)\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "bulk_add_meta_field": "jq \".specs |= with_entries(.value.__meta.updated = \\\"2025-12-25\\\")\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "deep_merge_data": "jq \".specs[\\\"spec-id\\\"] |= . * {new_field: \\\"value\\\", nested: {key: \\\"val\\\"}}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "filter_and_rebuild": "jq \".specs |= with_entries(select(.value.__meta.status != \\\"deprecated\\\"))\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json"
            }
          },
          "workflow": {
            "description": "Worker follows a consultative approach when helping users implement new specs",
            "new_spec_creation": {
              "phase_1_gather_requirements": {
                "description": "Before writing any spec, worker asks clarifying questions to understand all details",
                "questions_to_ask": [
                  "What is the spec ID (kebab-case)?",
                  "What type is this spec (api, component, model, feature, etc.)?",
                  "What is the purpose/description of this spec?",
                  "What files/locations will be affected?",
                  "Are there any dependencies or related specs?",
                  "What tags should be applied?",
                  "Should this include a tasks array for traceability?",
                  "Are there nested child specs or components?",
                  "What is the expected behavior or implementation details?"
                ],
                "approach": "Ask questions conversationally, not as a checklist. Adapt based on user responses and spec type.",
                "goal": "Gather complete understanding before proposing any spec structure"
              },
              "phase_2_propose_draft": {
                "description": "Once all details are clear, propose a complete draft spec structure",
                "actions": [
                  "Show the proposed JSON structure to the user",
                  "Explain the structure and any design decisions",
                  "Ask for confirmation or adjustments"
                ]
              },
              "phase_3_write_spec": {
                "description": "After user approval, write the spec to source.json",
                "actions": [
                  "Use jq to add the spec with status: draft",
                  "Validate the JSON structure",
                  "Confirm successful creation",
                  "Show the final spec to the user"
                ]
              }
            },
            "philosophy": "Measure twice, cut once - thorough understanding before implementation prevents rework"
          },
          "context_management": {
            "description": "Strategy for querying JSON specs to maintain efficient context usage",
            "principles": [
              "Query first level of depth for broad context awareness",
              "Include worker context itself in initial bootstrap",
              "Dynamically extend context selectively based on actual needs",
              "Avoid loading large nested JSON objects upfront"
            ],
            "bootstrap_queries": {
              "worker_config": "jq '.worker' .jkspec/source.json",
              "project_overview": "jq '.project' .jkspec/source.json",
              "spec_list": "jq '.specs | keys' .jkspec/source.json",
              "spec_first_level": "jq '.specs | with_entries(.value |= {__meta})' .jkspec/source.json"
            },
            "selective_deepening": {
              "description": "Only query deeper levels when specific information is needed",
              "examples": {
                "when_needed": "User asks to implement a specific spec",
                "query_pattern": "jq '.specs[\"specific-spec\"]' .jkspec/source.json",
                "nested_when_needed": "jq '.specs[\"parent\"].children[\"child\"]' .jkspec/source.json"
              }
            },
            "rationale": "Maintains efficient context window usage by loading only necessary information. Worker starts with high-level overview and drills down selectively rather than loading entire nested structures."
          },
          "modification_policy": {
            "description": "Guidelines for modifying worker behavior and understanding impact scope",
            "json_modifications": {
              "scope": "Changes to worker object in .jkspec/source.json",
              "impact": "Does NOT require CLI agent tooling reset",
              "reason": "Worker recontextualizes itself dynamically by reading worker object on bootstrap",
              "examples": [
                "Adding new guidelines",
                "Modifying commands list",
                "Updating policies",
                "Adding workflow steps",
                "Changing context management strategy"
              ],
              "agent_behavior": "Worker reads .worker on initialization via bootstrap command, so changes take effect immediately on next invocation"
            },
            "agent_file_modifications": {
              "scope": "Changes to .opencode/agent/jkspec-worker.md agent definition file",
              "impact": "REQUIRES full reset of CLI agent tooling",
              "reason": "Agent file defines core agent initialization, tools, and system prompts that are loaded by CLI at startup",
              "examples": [
                "Modifying agent system prompt",
                "Changing bootstrap instructions",
                "Updating tool access patterns",
                "Altering core agent behavior"
              ],
              "reset_procedure": "Restart or reinitialize the CLI agent tooling to reload the agent definition file"
            },
            "command_file_modifications": {
              "scope": "Changes to individual command files in .opencode/commands/",
              "impact": "Does NOT require CLI reset (similar to JSON modifications)",
              "reason": "Command files are read dynamically when commands are invoked",
              "note": "Worker reads command markdown files on-demand when executing specific commands"
            },
            "best_practice": "Prefer modifying worker JSON object for behavioral changes to avoid needing CLI resets. Reserve agent file modifications for fundamental structural changes."
          }
        },
        "traceability": {
          "__meta": {
            "type": "meta-guideline",
            "description": "Guideline for creating traceable specs with implementation status tracking using task arrays",
            "status": "active",
            "tags": [
              "meta",
              "guideline",
              "traceability"
            ],
            "purpose": "Define a standardized pattern for tracking implementation tasks within specs to ensure clear traceability between specification and actual code"
          },
          "concept": "When creating code-related specs, include a tasks array where each element is a task object containing name, description, and done status",
          "pattern": {
            "tasks": {
              "description": "Array of task objects",
              "task_structure": {
                "name": "string - Short name for the task",
                "description": "string - Detailed description of what needs to be done",
                "done": "boolean - false when not implemented, true when implemented"
              }
            }
          },
          "rationale": "Provides granular tracking of implementation progress with self-documenting task objects, enables clear verification of spec completion, maintains natural ordering, and keeps traceability between requirements and code",
          "when_to_use": "Propose this pattern when user creates specs that involve code implementation (files, components, APIs, features, etc.)",
          "example_spec": {
            "example-api": {
              "__meta": {
                "type": "api",
                "description": "Example REST API endpoint",
                "status": "draft"
              },
              "tasks": [
                {
                  "name": "Create handler",
                  "description": "Create endpoint handler function",
                  "done": false
                },
                {
                  "name": "Add validation",
                  "description": "Add input validation for request parameters",
                  "done": false
                },
                {
                  "name": "Write tests",
                  "description": "Write unit tests for the endpoint",
                  "done": false
                }
              ]
            }
          },
          "best_practices": [
            "Order tasks in logical sequence (implementation order)",
            "Use concise but clear names for tasks",
            "Provide detailed descriptions explaining what each task involves",
            "Set all task.done to false initially when spec is created",
            "Update task.done to true as each component is implemented",
            "Consider updating overall spec status to active when all tasks are done"
          ],
          "advantages": [
            "Natural ordering - tasks appear in implementation sequence",
            "Easy to iterate - can use array methods and jq array operations",
            "Simple indexing - access by position (tasks[0], tasks[1], etc.)",
            "Clean structure - no need for numbered keys",
            "Easy to add/remove tasks without renumbering"
          ],
          "agent_behavior": "When user requests to create a spec related to code, suggest including the tasks array pattern and offer to add task objects based on the spec requirements"
        },
        "readme-documentation": {
          "__meta": {
            "type": "documentation",
            "description": "README.md documentation for jkspec project with vision, advantages, disadvantages, and buy-me-a-coffee support button",
            "status": "active",
            "tags": [
              "documentation",
              "meta",
              "readme"
            ],
            "location": "README.md",
            "purpose": "Provide clear, honest documentation about jkspec as a prototype with potential for agent-driven development"
          },
          "sections": {
            "header": {
              "title": "jkspec",
              "tagline": "JSON-based specification format for rapid AI agent context retrieval"
            },
            "what_is_jkspec": {
              "description": "Explain what jkspec is and its core purpose",
              "content_draft": "jkspec is a single-file, JSON-based specification format designed to eliminate the context-gathering overhead AI agents face when working with codebases. Instead of agents spending time exploring directories, reading multiple files, and piecing together project structure, jkspec provides a centralized `.jkspec/source.json` file that agents can query instantly using `jq`.\n\nThink of it as a \"map\" for AI agents - a structured, queryable source of truth about your project's architecture, components, conventions, and implementation status."
            },
            "vision": {
              "description": "The vision and philosophy behind jkspec",
              "content_draft": "The vision of jkspec emerged from observing a consistent pattern: AI agents waste significant time and tokens exploring codebases before they can start actual work. Every conversation begins with \"let me look at your project structure\" followed by multiple file reads and questions.\n\njkspec flips this paradigm. What if agents could instantly access:\n- Project architecture and conventions\n- What exists and what doesn't\n- Implementation status of features\n- Dependencies and relationships\n- Historical decisions and rationale\n\nAll queryable in milliseconds with simple `jq` commands.\n\nThe broader vision is **spec-driven development with AI agents** - where specifications aren't just documentation, but active, queryable contracts that guide agent behavior and reduce ambiguity."
            },
            "prototype_notice": {
              "description": "Transparent notice that this is a prototype",
              "tone": "honest and encouraging",
              "content_draft": "⚠️ **This is a prototype.** jkspec is an experiment in improving AI agent workflows. It's rough around the edges, the conventions are still evolving, and there are likely better ways to solve some of these problems.\n\nThat said, I've found it genuinely useful in my own agent-assisted development, and I believe the core idea has potential. If you're interested in exploring new ways to work with AI coding assistants, give it a try. Feedback, ideas, and constructive criticism are welcome."
            },
            "advantages": {
              "description": "Key advantages of using jkspec",
              "items": [
                {
                  "title": "Instant Context",
                  "description": "Agents get full project context in a single jq query - no exploration needed"
                },
                {
                  "title": "Single Source of Truth",
                  "description": "One file contains architecture, conventions, specs, and status - no scattered documentation"
                },
                {
                  "title": "Queryable Structure",
                  "description": "Use jq to filter by type, status, tags - agents can find exactly what they need"
                },
                {
                  "title": "Implementation Tracking",
                  "description": "Track what's draft vs active vs deprecated - clear visibility into project state"
                },
                {
                  "title": "Hierarchical Specs",
                  "description": "Nest specs arbitrarily deep to match your architecture - from high-level features down to specific validations"
                },
                {
                  "title": "Version Control Friendly",
                  "description": "JSON file diffs clearly show spec changes - easy to review and track evolution"
                },
                {
                  "title": "No External Dependencies",
                  "description": "Just JSON and jq - no special tools or frameworks required"
                },
                {
                  "title": "Agent-Optimized",
                  "description": "Designed specifically for AI agent consumption, not just human documentation"
                }
              ]
            },
            "disadvantages": {
              "description": "Honest assessment of current limitations and tradeoffs",
              "items": [
                {
                  "title": "Manual Sync Required",
                  "description": "Specs don't automatically update when code changes - requires discipline to keep in sync"
                },
                {
                  "title": "Learning Curve",
                  "description": "Requires learning jq syntax and understanding the jkspec structure conventions"
                },
                {
                  "title": "JSON Verbosity",
                  "description": "JSON can be verbose - large projects might have unwieldy source.json files"
                },
                {
                  "title": "Not Human-Optimized",
                  "description": "Reading raw JSON isn't as pleasant as markdown docs for humans (though agents don't mind)"
                },
                {
                  "title": "Prototype Limitations",
                  "description": "Conventions still evolving, tooling is minimal, edge cases not fully explored"
                },
                {
                  "title": "Single File Bottleneck",
                  "description": "All specs in one file can cause merge conflicts in team environments"
                },
                {
                  "title": "No Schema Validation Yet",
                  "description": "While a schema exists, enforcement and validation tooling is minimal"
                }
              ]
            },
            "quick_start": {
              "description": "Basic quick start instructions",
              "content_draft": "1. Clone jkspec into your project (without git history):\n   ```bash\n   npx degit jkf16m/jkspec .jkspec\n   ```\n\n2. The `.jkspec/source.json` file is your starting template - customize it:\n   - Update the `project` section with your project details\n   - **NEVER remove `__jkspec`** - it defines the jkspec framework itself\n   - Modifying `__jkspec` means modifying the framework (jkspec is self-modifiable by design)\n   - Add your own specs to the `specs` object using kebab-case keys\n\n3. Query with jq: `jq '.specs' .jkspec/source.json`\n\nFor AI agents: Point your agent to `.jkspec/source.json` and give it access to `jq`."
            },
            "core_concepts": {
              "description": "Brief explanation of core jkspec concepts",
              "concepts": [
                {
                  "name": "Specs",
                  "description": "Each spec has a `__meta` object (type, description, status, tags) plus any custom fields"
                },
                {
                  "name": "Status Lifecycle",
                  "description": "draft → active → deprecated"
                },
                {
                  "name": "Hierarchical Structure",
                  "description": "Specs can nest using keys like children, components, endpoints, tests, etc."
                },
                {
                  "name": "Internal Specs",
                  "description": "Specs prefixed with `__` are internal/meta specs that define the framework itself (like `__jkspec`). These specs should never be deleted. Modifying them means modifying the jkspec framework behavior - the framework is intentionally self-modifiable"
                },
                {
                  "name": "jq Queries",
                  "description": "Direct JSON manipulation using jq for all read/write operations"
                }
              ]
            },
            "examples": {
              "description": "Practical jq examples",
              "queries": [
                {
                  "description": "List all specs",
                  "command": "jq .specs | keys .jkspec/source.json"
                },
                {
                  "description": "Get a specific spec",
                  "command": "jq .specs[\"spec-name\"] .jkspec/source.json"
                },
                {
                  "description": "Find all draft specs",
                  "command": "jq .specs | to_entries[] | select(.value.__meta.status == \"draft\") .jkspec/source.json"
                },
                {
                  "description": "Filter by type",
                  "command": "jq .specs | to_entries[] | select(.value.__meta.type == \"api\") .jkspec/source.json"
                }
              ]
            },
            "use_cases": {
              "description": "When jkspec might be useful",
              "scenarios": [
                "Working with AI coding agents frequently",
                "Want to reduce agent context-gathering overhead",
                "Need structured, queryable project documentation",
                "Exploring spec-driven development approaches",
                "Building agent-first development workflows"
              ]
            },
            "support": {
              "description": "Buy me a coffee section at the end",
              "content_draft": "If you find jkspec useful or interesting, consider buying me a coffee! This is a personal experiment and any support helps me continue exploring ideas like this.\n\n[![Buy Me A Coffee](https://www.buymeacoffee.com/assets/img/custom_images/orange_img.png)](https://buymeacoffee.com/jdfm24)"
            }
          },
          "tasks": [
            {
              "name": "Write header and tagline",
              "description": "Create project title and compelling tagline",
              "done": true
            },
            {
              "name": "Write What is jkspec section",
              "description": "Clear explanation of what jkspec is and core purpose",
              "done": true
            },
            {
              "name": "Write Vision section",
              "description": "Explain the vision and philosophy behind jkspec",
              "done": true
            },
            {
              "name": "Write Prototype Notice",
              "description": "Honest, encouraging notice about prototype status",
              "done": true
            },
            {
              "name": "Write Advantages section",
              "description": "List key advantages with clear descriptions",
              "done": true
            },
            {
              "name": "Write Disadvantages section",
              "description": "Honest assessment of limitations and tradeoffs",
              "done": true
            },
            {
              "name": "Write Quick Start section",
              "description": "Simple getting started instructions",
              "done": true
            },
            {
              "name": "Write Core Concepts section",
              "description": "Brief explanation of key jkspec concepts",
              "done": true
            },
            {
              "name": "Write Examples section",
              "description": "Practical jq query examples",
              "done": true
            },
            {
              "name": "Write Use Cases section",
              "description": "When jkspec might be useful",
              "done": true
            },
            {
              "name": "Add Buy Me a Coffee section",
              "description": "Add support button with link at the end",
              "done": true
            },
            {
              "name": "Review and polish",
              "description": "Final review for tone, clarity, and completeness",
              "done": true
            }
          ],
          "style_guidelines": {
            "tone": "Honest, pragmatic, encouraging",
            "voice": "First-person when discussing prototype status and personal experience",
            "technical_level": "Accessible to developers familiar with JSON and basic command-line tools",
            "approach": "Lead with value proposition, be transparent about limitations, focus on practical utility"
          }
        },
        "dual-file-architecture": {
          "__meta": {
            "type": "architecture",
            "description": "Dual-file architecture separating jkspec framework from project specifications",
            "status": "draft",
            "tags": [
              "architecture",
              "meta",
              "separation-of-concerns"
            ],
            "purpose": "Enable clean separation between jkspec framework tooling and user project specs, allowing framework updates without affecting project data",
            "complexity": "high",
            "subagent_required": true
          },
          "rationale": {
            "problem": "Currently .jkspec/source.json contains both jkspec framework specs (__jkspec) and project specs. This makes it difficult to update jkspec tooling without affecting user data.",
            "solution": "Split into two files: .jkspec/source.json (framework) and .jkspec-project/project.json (user specs). Users can update framework by cloning fresh .jkspec/ directory.",
            "benefits": [
              "Clear separation between framework and project data",
              "Users can update jkspec by deleting .jkspec/ and cloning fresh",
              "Project specs remain untouched during framework updates",
              "Transferable project.json can be shared across teams",
              "Framework and project can evolve independently"
            ]
          },
          "architecture": {
            "framework_location": {
              "path": ".jkspec/",
              "description": "Contains jkspec framework specifications and tooling",
              "files": {
                "source.json": {
                  "description": "Framework specifications including __jkspec meta specs",
                  "contains": [
                    "project metadata about jkspec itself",
                    "__jkspec spec with all framework components",
                    "worker configuration",
                    "Internal framework specs only"
                  ],
                  "modifiable": "Only when modifying the jkspec framework itself"
                },
                "jkspec.schema.json": {
                  "description": "JSON Schema used by both source.json and project.json",
                  "shared": true
                }
              }
            },
            "project_location": {
              "path": ".jkspec-project/",
              "description": "Contains user project specifications",
              "files": {
                "project.json": {
                  "description": "User project specifications",
                  "schema": "Uses .jkspec/jkspec.schema.json",
                  "contains": [
                    "project metadata for the user's actual project",
                    "User-defined specs (no __ prefix)",
                    "Project-specific conventions and decisions",
                    "All user spec data"
                  ],
                  "transferable": true,
                  "modifiable": "Users freely modify this for their project"
                }
              },
              "note": "Not created in jkspec repo - only in user projects"
            }
          },
          "schema_usage": {
            "description": "Both files use the same jkspec.schema.json for validation",
            "framework_file": ".jkspec/source.json validates against .jkspec/jkspec.schema.json",
            "project_file": ".jkspec-project/project.json validates against .jkspec/jkspec.schema.json",
            "shared_structure": {
              "project": "Both files have project object with different metadata",
              "specs": "Both files have specs object with different content",
              "worker": ".jkspec/source.json contains worker config, .jkspec-project/project.json does not need it"
            }
          },
          "agent_behavior": {
            "initialization": {
              "description": "How agents should initialize and discover spec files",
              "discovery_order": [
                "1. Check if .jkspec-project/ directory exists",
                "2. If not exists, create .jkspec-project/ directory",
                "3. Check if .jkspec-project/project.json exists",
                "4. If not exists, create project.json with minimal template",
                "5. Always read .jkspec/source.json for framework specs and worker config",
                "6. Always read .jkspec-project/project.json for user project specs"
              ]
            },
            "bootstrap_modification": {
              "description": "Worker bootstrap needs to check for project file existence",
              "location": "Update worker.bootstrap or add to worker guidelines",
              "new_checks": [
                "Check .jkspec-project/ existence before any operations",
                "Auto-create .jkspec-project/project.json if missing",
                "Inform user when creating new project file"
              ]
            },
            "query_strategy": {
              "framework_queries": "Use .jkspec/source.json for framework and worker info",
              "project_queries": "Use .jkspec-project/project.json for user project specs",
              "combined_view": "Agents may need to query both files for complete context"
            }
          },
          "migration": {
            "description": "How to migrate existing projects from single-file to dual-file",
            "from_current_structure": {
              "step_1": "Identify user specs (non-__ prefix) in current .jkspec/source.json",
              "step_2": "Create .jkspec-project/ directory",
              "step_3": "Create project.json with project metadata and user specs only",
              "step_4": "Remove user specs from .jkspec/source.json, keep only __jkspec and framework specs",
              "step_5": "Update .jkspec/source.json project metadata to describe jkspec framework itself",
              "step_6": "Test agent queries against both files"
            }
          },
          "project_json_template": {
            "description": "Minimal template for new .jkspec-project/project.json",
            "template": {
              "project": {
                "name": "your-project-name",
                "description": "Your project description",
                "version": "0.1.0",
                "architecture": {
                  "style": "Define your architecture style",
                  "pattern": "Define your patterns"
                },
                "conventions": {
                  "spec_location": ".jkspec-project/project.json"
                },
                "decisions": []
              },
              "specs": {}
            }
          },
          "worker_integration": {
            "description": "How worker commands should integrate with dual-file architecture",
            "command_modifications": {
              "jkspec-extend": "Should add user specs to .jkspec-project/project.json, not source.json",
              "jkspec-update": "Should determine which file to update based on spec prefix (__ = source.json, else = project.json)",
              "jkspec-validate": "Should validate both files",
              "jkspec-analyze": "Should analyze both files and report on each",
              "jkspec-suggest-specs": "Should suggest specs for project.json",
              "jkspec-test-sync": "Should check implementations for specs in project.json",
              "jkspec-implement": "Should work with specs from project.json",
              "jkspec-explain": "Should explain specs from either file",
              "jkspec-verify": "Should verify implementations from project.json"
            },
            "file_selection_logic": {
              "rule_1": "If spec-id starts with __, use .jkspec/source.json (framework)",
              "rule_2": "If spec-id does NOT start with __, use .jkspec-project/project.json (user project)",
              "rule_3": "Worker config always read from .jkspec/source.json",
              "rule_4": "Project specs always read from .jkspec-project/project.json"
            }
          },
          "tasks": [
            {
              "name": "Update worker bootstrap guidelines",
              "description": "Add project file discovery to worker.guidelines so agents know to check for .jkspec-project/project.json",
              "done": false
            },
            {
              "name": "Add schema validation spec",
              "description": "Add or update spec documenting that validation uses ajv for both source.json and project.json",
              "done": false
            },
            {
              "name": "Create dual-file architecture tests",
              "description": "Create tests in .jkspec/tests/ to verify agent behavior with dual-file setup",
              "done": false
            },
            {
              "name": "Update worker commands documentation",
              "description": "Update command markdown files to document file selection logic (__ prefix = source.json, no prefix = project.json)",
              "done": false
            },
            {
              "name": "Update README with dual-file explanation",
              "description": "Document in README that users get project.json auto-created in their projects",
              "done": false
            }
          ],
          "implementation_note": "This is a meta-spec only. The .jkspec-project/ directory and project.json file are NOT created in the jkspec repository itself. They are auto-created by agents when users use jkspec in their own projects.",
          "test_scenarios": {
            "description": "Test scenarios to verify dual-file architecture behavior",
            "test_location": ".jkspec/tests/dual-file-architecture/",
            "scenarios": {
              "project_json_discovery": {
                "description": "Test that agents properly discover or create project.json",
                "setup": "Temporary directory with .jkspec/ but no .jkspec-project/",
                "expected": "Agent creates .jkspec-project/project.json with minimal template",
                "test_file": "test_project_discovery.js"
              },
              "file_selection_by_prefix": {
                "description": "Test that __ prefix specs route to source.json, others to project.json",
                "setup": "Both source.json and project.json exist",
                "operations": [
                  "Query __jkspec spec - should read from source.json",
                  "Query user-spec (no __) - should read from project.json",
                  "Add spec with __ prefix - should write to source.json",
                  "Add spec without __ prefix - should write to project.json"
                ],
                "test_file": "test_file_selection.js"
              },
              "schema_validation_both_files": {
                "description": "Test that validation validates both files",
                "setup": "Both source.json and project.json with valid specs",
                "expected": "Both files pass ajv validation against jkspec.schema.json",
                "test_file": "test_schema_validation.js"
              },
              "project_json_optional": {
                "description": "Test that operations work when project.json does not exist",
                "setup": "Only .jkspec/source.json exists",
                "expected": "Framework queries work, user spec queries create project.json",
                "test_file": "test_optional_project.js"
              },
              "migration_scenario": {
                "description": "Test migration from single-file to dual-file",
                "setup": "Old source.json with both __ and user specs",
                "operation": "Run migration to split into source.json and project.json",
                "expected": "__ specs remain in source.json, user specs move to project.json",
                "test_file": "test_migration.js"
              }
            }
          },
          "schema_handling": {
            "description": "How schema files are handled in dual-file architecture",
            "schema_location": ".jkspec/jkspec.schema.json",
            "shared_schema": "Both source.json and project.json validate against the same schema file",
            "user_projects": {
              "option_1": {
                "approach": "Reference schema from .jkspec/ directory",
                "validation_path": ".jkspec/jkspec.schema.json",
                "note": "Schema is part of framework, gets updated with framework updates"
              },
              "option_2": {
                "approach": "Copy schema to .jkspec-project/ directory",
                "validation_path": ".jkspec-project/jkspec.schema.json",
                "note": "Allows offline validation, but needs manual sync with framework updates"
              },
              "recommended": "option_1 - Keep schema in .jkspec/ as single source of truth"
            },
            "validation_command": "Validation should always reference .jkspec/jkspec.schema.json regardless of which file is being validated"
          }
        },
        "schema-validation": {
          "__meta": {
            "type": "validation",
            "description": "JSON Schema validation for jkspec files using ajv",
            "status": "draft",
            "tags": [
              "validation",
              "schema",
              "ajv"
            ],
            "purpose": "Define validation strategy for both source.json and project.json files"
          },
          "validator": {
            "tool": "ajv",
            "description": "AJV (Another JSON Schema Validator) - fast JSON schema validator",
            "package": "ajv",
            "why_ajv": "Industry-standard, performant, supports JSON Schema draft 2020-12"
          },
          "files_to_validate": {
            "framework_file": {
              "path": ".jkspec/source.json",
              "schema": ".jkspec/jkspec.schema.json",
              "description": "Framework specifications including __jkspec meta specs"
            },
            "project_file": {
              "path": ".jkspec-project/project.json",
              "schema": ".jkspec/jkspec.schema.json",
              "description": "User project specifications - only validated if file exists",
              "optional": true
            }
          },
          "validation_rules": {
            "required_fields": [
              "All specs must have __meta with type, description, status",
              "Root must have project and specs objects"
            ],
            "spec_id_format": "Must use kebab-case (lowercase with hyphens)",
            "status_values": [
              "draft",
              "active",
              "deprecated"
            ],
            "internal_specs": "Specs with __ prefix should only exist in source.json"
          },
          "validation_command": {
            "description": "jkspec-validate command validates both files",
            "behavior": [
              "Validate .jkspec/source.json against schema",
              "Check if .jkspec-project/project.json exists",
              "If exists, validate .jkspec-project/project.json against schema",
              "Report validation results for both files"
            ]
          },
          "tasks": [
            {
              "name": "Install ajv dependency",
              "description": "Add ajv package for JSON schema validation",
              "done": false
            },
            {
              "name": "Create validation script",
              "description": "Create validation script that uses ajv to validate both files",
              "done": false
            },
            {
              "name": "Integrate with jkspec-validate command",
              "description": "Update jkspec-validate command to use ajv validation",
              "done": false
            },
            {
              "name": "Add validation tests",
              "description": "Create tests for schema validation with valid and invalid specs",
              "done": false
            }
          ]
        }
      }
    }
  },
  "worker": {
    "bootstrap": {
      "first_command": "jq '.worker' .jkspec/source.json",
      "description": "On initialization, agent must read the worker object which contains all operational definitions"
    },
    "commands_location": ".opencode/command",
    "commands_description": "All jkspec-worker commands are defined as individual markdown files in .opencode/commands/ directory. Each command file contains description, steps, and additional context.",
    "available_commands": [
      "jkspec-extend",
      "jkspec-update",
      "jkspec-validate",
      "jkspec-analyze",
      "jkspec-suggest-specs",
      "jkspec-test-sync",
      "jkspec-implement",
      "jkspec-explain",
      "jkspec-verify"
    ],
    "reading_policy": {
      "description": "Use jq directly to read and manipulate .jkspec/source.json",
      "philosophy": "Direct JSON manipulation with jq is simpler and more transparent than abstracting behind a CLI tool",
      "common_operations": {
        "read_spec": "jq \".specs[\\\"spec-id\\\"]\" .jkspec/source.json",
        "read_spec_meta": "jq \".specs[\\\"spec-id\\\"].__meta\" .jkspec/source.json",
        "list_specs": "jq \".specs | keys\" .jkspec/source.json",
        "get_worker_config": "jq \".worker\" .jkspec/source.json",
        "get_project_info": "jq \".project\" .jkspec/source.json",
        "filter_by_type": "jq \".specs | to_entries[] | select(.value.__meta.type == \\\"api\\\")\" .jkspec/source.json",
        "filter_by_status": "jq \".specs | to_entries[] | select(.value.__meta.status == \\\"draft\\\")\" .jkspec/source.json"
      },
      "best_practices": [
        "Always use tmp.json pattern when modifying: jq '...' file.json > tmp.json && mv tmp.json file.json",
        "Validate JSON after modifications with: jq empty .jkspec/source.json",
        "Use --arg for passing variables to avoid shell escaping issues",
        "Use -r flag for raw output when you need unquoted strings",
        "Test complex jq queries with read-only operations first"
      ]
    },
    "guidelines": [
      "Always validate input - check spec-id naming conventions and required fields",
      "Use jq for all spec reading and modifications",
      "Be concise and provide clear, actionable output",
      "Show results after operations",
      "Handle errors gracefully with explanations",
      "Follow kebab-case convention for spec IDs",
      "Be autonomous within spec scope",
      "Ensure thorough implementation according to requirements",
      "Dual-file architecture: Check for .jkspec-project/project.json for user project specs, use .jkspec/source.json for framework specs",
      "File selection: Specs with __ prefix go to source.json (framework), specs without __ prefix go to project.json (user project)",
      "Auto-create project.json: If .jkspec-project/project.json does not exist, create it with minimal template on first user spec operation",
      "Always validate both source.json and project.json against jkspec.schema.json using ajv",
      "After ANY modification to source.json or project.json, IMMEDIATELY validate against jkspec.schema.json using: ajv validate -s .jkspec/jkspec.schema.json -d <file> --spec=draft2020 --strict=false. If validation fails, fix the issue before proceeding."
    ],
    "complex_specs": {
      "description": "How to handle specs with multiple components",
      "approach": [
        "Identify child specs (look for children, specs, tests fields)",
        "Break down work into components",
        "Implement systematically through each component",
        "Track progress and update status fields",
        "Report comprehensively on all components"
      ]
    },
    "subagent_policy": {
      "description": "When and how jkspec-worker spawns subagents for complex implementation tasks",
      "when_to_spawn": [
        "Spec has subagent_required: true in __meta",
        "Spec has complexity: high and involves significant implementation work",
        "User explicitly requests subagent usage",
        "Implementation involves multiple files or coordinated changes",
        "Task requires sustained focus beyond simple edits"
      ],
      "how_to_spawn": {
        "use_task_tool": "Use the Task tool to spawn general-purpose subagent",
        "provide_full_spec": "Pass complete spec details to subagent including all requirements, tasks, and constraints",
        "clear_instructions": "Give subagent explicit instructions on what to implement and how to verify correctness",
        "result_reporting": "Subagent should report back implementation status and any issues encountered"
      },
      "worker_responsibilities": [
        "Read and understand spec before spawning subagent",
        "Determine if subagent is needed based on complexity",
        "Prepare comprehensive prompt for subagent with all necessary context",
        "Monitor subagent work and integrate results",
        "Update spec status and tasks array after subagent completes work"
      ],
      "example_workflow": "1. Read spec with jq\n2. Check complexity and subagent_required fields\n3. If needed, use Task tool to spawn subagent with full spec context\n4. Subagent implements according to spec requirements\n5. Worker verifies implementation and updates spec status"
    }
  }
}
