{
  "project": {
    "name": "jkspec",
    "description": "JSON-based specification format for rapid AI agent context retrieval. Provides jkspec-template as a starter template for projects.",
    "version": "0.1.0",
    "architecture": {
      "style": "single-file specification",
      "pattern": "spec-driven development",
      "philosophy": "Provide AI agents with structured, queryable context to eliminate codebase exploration overhead"
    },
    "conventions": {
      "spec_location": ".jkspec/source.json",
      "query_tool": "jq",
      "spec_keys": "Use kebab-case for spec identifiers (e.g., 'auth-service', 'user-model')",
      "internal_specs": "Specs prefixed with __ are internal/meta specs (e.g., '__jkspec')",
      "versioning": "Semantic versioning for the spec format itself"
    },
    "decisions": [
      {
        "id": "ADR-001",
        "title": "Use single JSON file as source of truth",
        "status": "accepted",
        "date": "2025-12-25",
        "context": "AI agents waste time exploring codebases. Need fast, precise context retrieval.",
        "decision": "Use single .jkspec/source.json file with structured data, queryable via jq",
        "consequences": "Agents get instant context. Must maintain spec alongside code. JSON parsing overhead minimal."
      },
      {
        "id": "ADR-002",
        "title": "Use object for specs instead of array",
        "status": "accepted",
        "date": "2025-12-25",
        "context": "Need to avoid duplicate keys and enable direct access",
        "decision": "Use object with unique keys for specs: {\"spec-name\": {...}}",
        "consequences": "Direct access via jq '.specs[\"name\"]'. Natural key uniqueness. Slightly more verbose queries for filtering."
      },
      {
        "id": "ADR-003",
        "title": "Use __ prefix for internal specs",
        "status": "accepted",
        "date": "2025-12-25",
        "context": "Need to distinguish internal jkspec infrastructure from user specs",
        "decision": "Prefix internal/meta specs with __ (double underscore) to clearly mark them as part of jkspec itself",
        "consequences": "Users can easily identify and avoid modifying internal specs. Clear separation of concerns between framework and user content."
      },
      {
        "id": "ADR-004",
        "title": "Remove CLI abstraction, use jq directly",
        "status": "accepted",
        "date": "2025-12-25",
        "context": "CLI tool adds complexity and maintenance burden. AI agents are fluent in jq. Direct manipulation is more transparent.",
        "decision": "Remove jkspec CLI tool. Use jq directly for all read/write operations on .jkspec/source.json",
        "consequences": "Simpler architecture with fewer moving parts. Agent can see exact jq commands. Users learn standard jq instead of custom CLI. Slightly more verbose operations but more transparent and flexible."
      }
    ]
  },
  "specs": {
    "__jkspec": {
      "__meta": {
        "type": "meta",
        "description": "Internal jkspec system specification - contains all jkspec infrastructure components",
        "status": "active",
        "tags": [
          "internal",
          "meta",
          "jkspec-system"
        ],
        "note": "This is an internal spec. User specs should not use the __ prefix."
      },
      "components": {
        "format": {
          "__meta": {
            "type": "specification",
            "description": "The jkspec format itself - structure and conventions",
            "status": "active",
            "tags": [
              "meta",
              "format"
            ],
            "location": ".jkspec/source.json"
          },
          "structure": {
            "project": {
              "name": "string - project name",
              "description": "string - brief project description",
              "version": "string - semver",
              "architecture": "object - architectural overview",
              "conventions": "object - global coding and organizational conventions",
              "decisions": "array - architectural decision records"
            },
            "specs": {
              "description": "object - keyed by unique spec identifier",
              "spec_schema": {
                "__meta": {
                  "type": "string - spec type (api, model, component, etc.)",
                  "description": "string - what this spec describes",
                  "status": "string - draft, active, deprecated",
                  "tags": "array - searchable tags"
                },
                "...": "any additional fields relevant to the spec"
              }
            }
          },
          "examples": {
            "get_project_info": "jq \".project\" .jkspec/source.json",
            "list_all_specs": "jq \".specs | keys\" .jkspec/source.json",
            "get_specific_spec": "jq \".specs[\\\"spec-name\\\"]\" .jkspec/source.json",
            "get_spec_meta": "jq \".specs[\\\"spec-name\\\"].__meta\" .jkspec/source.json",
            "filter_by_type": "jq \".specs | to_entries[] | select(.value.__meta.type==\\\"api\\\")\" .jkspec/source.json",
            "filter_by_tag": "jq \".specs | to_entries[] | select(.value.__meta.tags[]? == \\\"authentication\\\")\" .jkspec/source.json",
            "filter_by_status": "jq \".specs | to_entries[] | select(.value.__meta.status == \\\"draft\\\")\" .jkspec/source.json"
          },
          "hierarchical_specifications": {
            "description": "Specs can contain nested child specifications at any depth using arbitrary keys",
            "common_keys": [
              "children",
              "specs",
              "tests",
              "endpoints",
              "components",
              "requirements"
            ],
            "status_lifecycle": {
              "draft": "Specification not yet implemented",
              "active": "Specification fully implemented and working",
              "deprecated": "Specification no longer in use"
            },
            "auto_draft_rule": "ANY modification to a spec (except direct status changes) automatically sets status to 'draft'. Modifying child specs also sets parent to 'draft'.",
            "philosophy": "Instead of redoing implementations, refine specs by adding more detailed child specifications to achieve more accurate results"
          },
          "nested_examples": {
            "simple_nesting": {
              "parent_spec": "__jkspec",
              "child_key": "components",
              "children": {
                "format": {
                  "__meta": {
                    "type": "specification",
                    "description": "The jkspec format specification",
                    "status": "active"
                  }
                }
              }
            },
            "deep_nesting": {
              "description": "Specs can nest arbitrarily deep with each level having its own __meta",
              "example": "auth-api > endpoints > login > validations > email-format",
              "structure": {
                "auth-api": {
                  "__meta": {
                    "type": "api",
                    "description": "Authentication API",
                    "status": "active"
                  },
                  "endpoints": {
                    "login": {
                      "__meta": {
                        "type": "endpoint",
                        "description": "Login endpoint",
                        "status": "active"
                      },
                      "validations": {
                        "email-format": {
                          "__meta": {
                            "type": "validation",
                            "description": "Email format validation",
                            "status": "active"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "jq_editing_examples": {
            "add_new_spec": "jq \".specs[\\\"new-spec-id\\\"] = {__meta: {type: \\\"component\\\", description: \\\"New component\\\", status: \\\"draft\\\", tags: [\\\"frontend\\\"]}}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "update_meta_field": "jq \".specs[\\\"spec-id\\\"].__meta.status = \\\"active\\\"\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "remove_spec": "jq \"del(.specs[\\\"spec-id\\\"])\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "add_nested_child": "jq \".specs[\\\"parent-id\\\"].children[\\\"child-id\\\"] = {__meta: {type: \\\"subcomponent\\\", description: \\\"Child spec\\\", status: \\\"draft\\\"}}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "update_nested_meta": "jq \".specs[\\\"parent-id\\\"].children[\\\"child-id\\\"].__meta.status = \\\"active\\\"\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "add_tag": "jq \".specs[\\\"spec-id\\\"].__meta.tags += [\\\"new-tag\\\"]\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "remove_tag": "jq \".specs[\\\"spec-id\\\"].__meta.tags -= [\\\"old-tag\\\"]\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "add_task": "jq \".specs[\\\"spec-id\\\"].tasks += [{name: \\\"Task name\\\", description: \\\"Task description\\\", done: false}]\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "mark_task_done": "jq \".specs[\\\"spec-id\\\"].tasks[0].done = true\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "update_multiple_meta": "jq \".specs[\\\"spec-id\\\"].__meta |= . + {status: \\\"active\\\", location: \\\"path/to/file\\\"}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "add_data_field": "jq \".specs[\\\"spec-id\\\"].custom_data = {key: \\\"value\\\"}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json"
          }
        },
        "depth-system": {
          "__meta": {
            "type": "feature",
            "description": "Single unified agent architecture where jkspec-worker handles all operations from high-level management to detailed implementation",
            "status": "active",
            "tags": [
              "architecture",
              "unified-agent"
            ],
            "purpose": "Simplified architecture with one agent that can handle any jkspec task",
            "location": ".opencode/agent/"
          },
          "concepts": {
            "spec_levels": {
              "simple": "Single file, small component, or focused investigation",
              "medium": "Module, service, or feature with multiple files",
              "complex": "System, architecture, or large-scale feature spanning multiple modules"
            },
            "unified_approach": "Single agent handles both management operations (add/update/validate specs) and implementation work (read/implement/verify specs)"
          },
          "agent_responsibilities": {
            "jkspec-worker": "Handles ALL operations: extends specs, validates structure, analyzes codebase, implements features, explains specs, and verifies implementations"
          },
          "implemented_in": [
            ".opencode/agent/jkspec-worker.md"
          ]
        },
        "worker": {
          "__meta": {
            "type": "agent",
            "description": "Unified agent for managing and implementing jkspec specifications - handles both high-level management operations and detailed implementation work",
            "status": "active",
            "tags": [
              "ai-agents",
              "management",
              "implementation"
            ],
            "purpose": "Single agent that can extend, validate, maintain jkspec files AND read/implement individual specs using jq directly",
            "location": ".opencode/agent/jkspec-worker.md",
            "dependencies": [
              "jq"
            ]
          },
          "capabilities": {
            "management": [
              "Add new specs (extend command)",
              "Update existing specs (update command)",
              "Validate jspec structure (validate command)",
              "Analyze specs and provide recommendations (analyze command)",
              "Suggest missing specs (suggest-specs command)",
              "Verify implementation status (test-sync command)"
            ],
            "implementation": [
              "Read and explain spec details (explain command)",
              "Implement specs according to requirements (implement command)",
              "Verify implementations match specs (verify command)",
              "Work with complex multi-component specs"
            ]
          },
          "commands": {
            "extend": "Add a new spec to the jspec file",
            "update": "Update an existing spec field",
            "validate": "Validate the jspec structure and check for inconsistencies",
            "analyze": "Analyze the current jkspec structure and provide recommendations",
            "suggest-specs": "Suggest missing specs based on codebase analysis",
            "test-sync": "Verify that all specs have corresponding implementations",
            "implement": "Implement a spec according to its requirements",
            "explain": "Read and explain a specific spec's details",
            "verify": "Verify if a spec is implemented correctly"
          },
          "jq_operations": {
            "reading": {
              "get_spec": "jq \".specs[\\\"spec-id\\\"]\" .jkspec/source.json",
              "get_spec_meta": "jq \".specs[\\\"spec-id\\\"].__meta\" .jkspec/source.json",
              "get_nested_spec": "jq \".specs[\\\"parent-id\\\"].children[\\\"child-id\\\"]\" .jkspec/source.json",
              "get_nested_meta": "jq \".specs[\\\"parent-id\\\"].children[\\\"child-id\\\"].__meta\" .jkspec/source.json",
              "list_all_specs": "jq \".specs | keys\" .jkspec/source.json",
              "list_specs_by_type": "jq \".specs | to_entries[] | select(.value.__meta.type == \\\"api\\\") | .key\" .jkspec/source.json",
              "list_specs_by_tag": "jq \".specs | to_entries[] | select(.value.__meta.tags[]? == \\\"backend\\\") | .key\" .jkspec/source.json",
              "get_all_draft_specs": "jq \".specs | to_entries[] | select(.value.__meta.status == \\\"draft\\\")\" .jkspec/source.json",
              "get_project_info": "jq \".project\" .jkspec/source.json"
            },
            "writing": {
              "add_spec": "jq \".specs[\\\"new-spec\\\"] = {__meta: {type: \\\"component\\\", description: \\\"Description\\\", status: \\\"draft\\\", tags: []}}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "update_meta_field": "jq \".specs[\\\"spec-id\\\"].__meta.status = \\\"active\\\"\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "add_data_field": "jq \".specs[\\\"spec-id\\\"].new_field = \\\"value\\\"\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "add_nested_spec": "jq \".specs[\\\"parent\\\"].children[\\\"child\\\"] = {__meta: {type: \\\"type\\\", description: \\\"desc\\\", status: \\\"draft\\\"}}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "add_tag": "jq \".specs[\\\"spec-id\\\"].__meta.tags += [\\\"new-tag\\\"]\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "update_multiple_meta": "jq \".specs[\\\"spec-id\\\"].__meta |= . + {status: \\\"active\\\", location: \\\"path/to/file\\\"}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json"
            },
            "deleting": {
              "remove_spec": "jq \"del(.specs[\\\"spec-id\\\"])\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "remove_nested": "jq \"del(.specs[\\\"parent\\\"].children[\\\"child\\\"])\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "remove_data_field": "jq \"del(.specs[\\\"spec-id\\\"].field_name)\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "remove_tag": "jq \".specs[\\\"spec-id\\\"].__meta.tags -= [\\\"tag-to-remove\\\"]\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "remove_meta_field": "jq \"del(.specs[\\\"spec-id\\\"].__meta.field_name)\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json"
            },
            "advanced": {
              "conditional_update": "jq \".specs |= with_entries(if .value.__meta.status == \\\"draft\\\" then .value.__meta.status = \\\"reviewed\\\" else . end)\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "bulk_add_meta_field": "jq \".specs |= with_entries(.value.__meta.updated = \\\"2025-12-25\\\")\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "deep_merge_data": "jq \".specs[\\\"spec-id\\\"] |= . * {new_field: \\\"value\\\", nested: {key: \\\"val\\\"}}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "filter_and_rebuild": "jq \".specs |= with_entries(select(.value.__meta.status != \\\"deprecated\\\"))\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json"
            }
          },
          "workflow": {
            "description": "Worker follows a consultative approach when helping users implement new specs",
            "new_spec_creation": {
              "phase_1_gather_requirements": {
                "description": "Before writing any spec, worker asks clarifying questions to understand all details",
                "questions_to_ask": [
                  "What is the spec ID (kebab-case)?",
                  "What type is this spec (api, component, model, feature, etc.)?",
                  "What is the purpose/description of this spec?",
                  "What files/locations will be affected?",
                  "Are there any dependencies or related specs?",
                  "What tags should be applied?",
                  "Should this include a tasks array for traceability?",
                  "Are there nested child specs or components?",
                  "What is the expected behavior or implementation details?"
                ],
                "approach": "Ask questions conversationally, not as a checklist. Adapt based on user responses and spec type.",
                "goal": "Gather complete understanding before proposing any spec structure"
              },
              "phase_2_propose_draft": {
                "description": "Once all details are clear, propose a complete draft spec structure",
                "actions": [
                  "Show the proposed JSON structure to the user",
                  "Explain the structure and any design decisions",
                  "Ask for confirmation or adjustments"
                ]
              },
              "phase_3_write_spec": {
                "description": "After user approval, write the spec to source.json",
                "actions": [
                  "Use jq to add the spec with status: draft",
                  "Validate the JSON structure",
                  "Confirm successful creation",
                  "Show the final spec to the user"
                ]
              }
            },
            "philosophy": "Measure twice, cut once - thorough understanding before implementation prevents rework"
          },
          "context_management": {
            "description": "Strategy for querying JSON specs to maintain efficient context usage",
            "principles": [
              "Query first level of depth for broad context awareness",
              "Include worker context itself in initial bootstrap",
              "Dynamically extend context selectively based on actual needs",
              "Avoid loading large nested JSON objects upfront"
            ],
            "bootstrap_queries": {
              "worker_config": "jq '.worker' .jkspec/source.json",
              "project_overview": "jq '.project' .jkspec/source.json",
              "spec_list": "jq '.specs | keys' .jkspec/source.json",
              "spec_first_level": "jq '.specs | with_entries(.value |= {__meta})' .jkspec/source.json"
            },
            "selective_deepening": {
              "description": "Only query deeper levels when specific information is needed",
              "examples": {
                "when_needed": "User asks to implement a specific spec",
                "query_pattern": "jq '.specs[\"specific-spec\"]' .jkspec/source.json",
                "nested_when_needed": "jq '.specs[\"parent\"].children[\"child\"]' .jkspec/source.json"
              }
            },
            "rationale": "Maintains efficient context window usage by loading only necessary information. Worker starts with high-level overview and drills down selectively rather than loading entire nested structures."
          }
        },
        "template": {
          "__meta": {
            "type": "template",
            "description": "Starter template for new jkspec projects",
            "status": "active",
            "tags": [
              "template",
              "setup"
            ],
            "location": "jkspec-template/"
          },
          "contents": {
            "source_json": ".jkspec/source.json with minimal project structure"
          }
        },
        "traceability": {
          "__meta": {
            "type": "meta-guideline",
            "description": "Guideline for creating traceable specs with implementation status tracking using task arrays",
            "status": "active",
            "tags": [
              "meta",
              "guideline",
              "traceability"
            ],
            "purpose": "Define a standardized pattern for tracking implementation tasks within specs to ensure clear traceability between specification and actual code"
          },
          "concept": "When creating code-related specs, include a tasks array where each element is a task object containing name, description, and done status",
          "pattern": {
            "tasks": {
              "description": "Array of task objects",
              "task_structure": {
                "name": "string - Short name for the task",
                "description": "string - Detailed description of what needs to be done",
                "done": "boolean - false when not implemented, true when implemented"
              }
            }
          },
          "rationale": "Provides granular tracking of implementation progress with self-documenting task objects, enables clear verification of spec completion, maintains natural ordering, and keeps traceability between requirements and code",
          "when_to_use": "Propose this pattern when user creates specs that involve code implementation (files, components, APIs, features, etc.)",
          "example_spec": {
            "example-api": {
              "__meta": {
                "type": "api",
                "description": "Example REST API endpoint",
                "status": "draft"
              },
              "tasks": [
                {
                  "name": "Create handler",
                  "description": "Create endpoint handler function",
                  "done": false
                },
                {
                  "name": "Add validation",
                  "description": "Add input validation for request parameters",
                  "done": false
                },
                {
                  "name": "Write tests",
                  "description": "Write unit tests for the endpoint",
                  "done": false
                }
              ]
            }
          },
          "best_practices": [
            "Order tasks in logical sequence (implementation order)",
            "Use concise but clear names for tasks",
            "Provide detailed descriptions explaining what each task involves",
            "Set all task.done to false initially when spec is created",
            "Update task.done to true as each component is implemented",
            "Consider updating overall spec status to active when all tasks are done"
          ],
          "advantages": [
            "Natural ordering - tasks appear in implementation sequence",
            "Easy to iterate - can use array methods and jq array operations",
            "Simple indexing - access by position (tasks[0], tasks[1], etc.)",
            "Clean structure - no need for numbered keys",
            "Easy to add/remove tasks without renumbering"
          ],
          "agent_behavior": "When user requests to create a spec related to code, suggest including the tasks array pattern and offer to add task objects based on the spec requirements"
        }
      }
    },
    "py-snake": {
      "__meta": {
        "type": "game",
        "description": "Classic Python snake game with pygame - grow by eating apples, track score, game over on collision",
        "status": "active",
        "tags": [
          "python",
          "pygame",
          "game"
        ],
        "location": "py-snake/"
      },
      "requirements": {
        "language": "Python 3.8+",
        "library": "pygame",
        "features": [
          "Snake grows when eating apples",
          "Game over on wall or self collision",
          "Score tracking based on apples eaten",
          "Visual game (no sound)",
          "Arrow key controls"
        ]
      },
      "components": {
        "snake": {
          "__meta": {
            "type": "component",
            "description": "Snake entity with movement, growth, collision detection, and rendering - complex component requiring dedicated implementation",
            "status": "active",
            "location": "py-snake/snake_game.py",
            "complexity": "high",
            "subagent_required": true
          },
          "data_structure": {
            "body": "List of (x, y) coordinate tuples representing each segment",
            "direction": "Current direction vector as (dx, dy) tuple",
            "pending_growth": "Integer tracking segments to add on next update"
          },
          "properties": {
            "initial_position": "(10, 10) grid coordinates",
            "initial_length": 3,
            "initial_direction": "(1, 0) moving right",
            "color": "RGB (0, 255, 0) green",
            "segment_size": "30 pixels (matching grid cell size)"
          },
          "behavior": {
            "movement": {
              "description": "Snake moves one grid cell per game tick in current direction",
              "implementation": "Add new head position in direction, remove tail segment (unless growing)",
              "direction_change": "Cannot reverse directly (e.g., if moving right, cannot go left)",
              "speed": "Game updates every 100ms"
            },
            "growth": {
              "description": "When apple eaten, snake grows by 1 segment",
              "implementation": "On apple collision, increment pending_growth. Do not remove tail segment on next move.",
              "visual": "Growth appears at tail end on next movement"
            },
            "collision_detection": {
              "self_collision": {
                "description": "Check if head position matches any body segment position",
                "trigger": "Game over"
              },
              "wall_collision": {
                "description": "Check if head x or y is outside grid bounds (0-19)",
                "trigger": "Game over"
              },
              "apple_collision": {
                "description": "Check if head position matches apple position",
                "trigger": "Increment score, grow snake, spawn new apple"
              }
            }
          },
          "methods": {
            "move": "Update snake position based on current direction and handle growth",
            "change_direction": "Set new direction if valid (not 180-degree turn)",
            "check_self_collision": "Return true if head collides with body",
            "check_wall_collision": "Return true if head is out of bounds",
            "grow": "Increment pending_growth counter",
            "render": "Draw all segments as rectangles on pygame surface"
          },
          "input_handling": {
            "arrow_up": "Set direction to (0, -1) if current direction is not (0, 1)",
            "arrow_down": "Set direction to (0, 1) if current direction is not (0, -1)",
            "arrow_left": "Set direction to (-1, 0) if current direction is not (1, 0)",
            "arrow_right": "Set direction to (1, 0) if current direction is not (-1, 0)"
          },
          "tasks": [
            {
              "name": "Initialize Snake class",
              "description": "Create Snake class with __init__ method setting up body list, direction, and growth counter",
              "done": false
            },
            {
              "name": "Implement move method",
              "description": "Add move logic that updates head position and handles tail removal/growth",
              "done": false
            },
            {
              "name": "Implement direction change",
              "description": "Add change_direction method with 180-degree turn prevention",
              "done": false
            },
            {
              "name": "Implement collision detection",
              "description": "Add methods for self, wall, and apple collision detection",
              "done": false
            },
            {
              "name": "Implement render method",
              "description": "Add rendering logic to draw all snake segments on pygame surface",
              "done": false
            }
          ]
        },
        "apple": {
          "__meta": {
            "type": "component",
            "description": "Apple/food entity with random spawning",
            "status": "active",
            "location": "py-snake/snake_game.py",
            "complexity": "low"
          },
          "properties": {
            "position": "(x, y) grid coordinates",
            "color": "RGB (255, 0, 0) red",
            "size": "30 pixels"
          },
          "behavior": {
            "spawning": "Generate random position within grid bounds, ensure not on snake body",
            "collision": "Detected when snake head matches apple position"
          }
        },
        "game-manager": {
          "__meta": {
            "type": "component",
            "description": "Main game loop, state management, and rendering coordination",
            "status": "active",
            "location": "py-snake/snake_game.py",
            "complexity": "medium"
          },
          "responsibilities": [
            "Initialize pygame and game window",
            "Handle main game loop and timing",
            "Process keyboard input events",
            "Coordinate snake and apple updates",
            "Render score display",
            "Handle game over state and display"
          ]
        }
      },
      "tasks": [
        {
          "name": "Setup project structure",
          "description": "Create py-snake/ directory and requirements.txt with pygame dependency",
          "done": true
        },
        {
          "name": "Implement Snake component",
          "description": "Create Snake class with all movement, growth, and collision logic (spawn subagent for this)",
          "done": true
        },
        {
          "name": "Implement Apple component",
          "description": "Create Apple class with random positioning logic",
          "done": true
        },
        {
          "name": "Implement Game Manager",
          "description": "Create main game loop with pygame window, event handling, and rendering coordination",
          "done": true
        },
        {
          "name": "Integrate components",
          "description": "Connect Snake, Apple, and Game Manager with proper event flow",
          "done": true
        },
        {
          "name": "Add score display",
          "description": "Display current score on screen using pygame font rendering",
          "done": true
        },
        {
          "name": "Add game over screen",
          "description": "Display game over message with final score and restart option",
          "done": true
        },
        {
          "name": "Create README",
          "description": "Add README.md with installation and play instructions",
          "done": true
        }
      ],
      "gameplay": {
        "controls": {
          "up": "Arrow Up",
          "down": "Arrow Down",
          "left": "Arrow Left",
          "right": "Arrow Right"
        },
        "rules": {
          "starting_length": 3,
          "growth_per_apple": 1,
          "game_over_conditions": [
            "Snake hits wall",
            "Snake hits itself"
          ],
          "scoring": "1 point per apple eaten"
        },
        "display": {
          "window_size": "600x600 pixels",
          "grid_size": "20x20 cells",
          "cell_size": "30 pixels",
          "colors": {
            "background": "black",
            "snake": "green",
            "apple": "red",
            "text": "white"
          }
        }
      }
    }
  },
  "worker": {
    "bootstrap": {
      "first_command": "jq '.worker' .jkspec/source.json",
      "description": "On initialization, agent must read the worker object which contains all operational definitions"
    },
    "commands_location": ".opencode/commands",
    "commands_description": "All jkspec-worker commands are defined as individual markdown files in .opencode/commands/ directory. Each command file contains description, steps, and additional context.",
    "available_commands": [
      "jkspec-extend",
      "jkspec-update",
      "jkspec-validate",
      "jkspec-analyze",
      "jkspec-suggest-specs",
      "jkspec-test-sync",
      "jkspec-implement",
      "jkspec-explain",
      "jkspec-verify"
    ],
    "reading_policy": {
      "description": "Use jq directly to read and manipulate .jkspec/source.json",
      "philosophy": "Direct JSON manipulation with jq is simpler and more transparent than abstracting behind a CLI tool",
      "common_operations": {
        "read_spec": "jq \".specs[\\\"spec-id\\\"]\" .jkspec/source.json",
        "read_spec_meta": "jq \".specs[\\\"spec-id\\\"].__meta\" .jkspec/source.json",
        "list_specs": "jq \".specs | keys\" .jkspec/source.json",
        "get_worker_config": "jq \".worker\" .jkspec/source.json",
        "get_project_info": "jq \".project\" .jkspec/source.json",
        "filter_by_type": "jq \".specs | to_entries[] | select(.value.__meta.type == \\\"api\\\")\" .jkspec/source.json",
        "filter_by_status": "jq \".specs | to_entries[] | select(.value.__meta.status == \\\"draft\\\")\" .jkspec/source.json"
      },
      "best_practices": [
        "Always use tmp.json pattern when modifying: jq '...' file.json > tmp.json && mv tmp.json file.json",
        "Validate JSON after modifications with: jq empty .jkspec/source.json",
        "Use --arg for passing variables to avoid shell escaping issues",
        "Use -r flag for raw output when you need unquoted strings",
        "Test complex jq queries with read-only operations first"
      ]
    },
    "guidelines": [
      "Always validate input - check spec-id naming conventions and required fields",
      "Use jq for all spec reading and modifications",
      "Be concise and provide clear, actionable output",
      "Show results after operations",
      "Handle errors gracefully with explanations",
      "Follow kebab-case convention for spec IDs",
      "Be autonomous within spec scope",
      "Ensure thorough implementation according to requirements"
    ],
    "complex_specs": {
      "description": "How to handle specs with multiple components",
      "approach": [
        "Identify child specs (look for children, specs, tests fields)",
        "Break down work into components",
        "Implement systematically through each component",
        "Track progress and update status fields",
        "Report comprehensively on all components"
      ]
    }
  }
}
