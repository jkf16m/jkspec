{
  "project": {
    "name": "jkspec",
    "description": "JSON-based specification format for rapid AI agent context retrieval. Provides jkspec-template as a starter template for projects.",
    "version": "0.1.0",
    "architecture": {
      "style": "single-file specification",
      "pattern": "spec-driven development",
      "philosophy": "Provide AI agents with structured, queryable context to eliminate codebase exploration overhead",
      "__meta": {
        "description": "Architectural overview and structure",
        "goal": "Architecture fields (style, pattern, philosophy) documented and reflect current state",
        "done": true
      }
    },
    "conventions": {
      "spec_location": ".jkspec/source.json",
      "query_tool": "jq",
      "spec_keys": "Use kebab-case for spec identifiers (e.g., 'auth-service', 'user-model')",
      "internal_specs": "Specs prefixed with __ are internal/meta specs (e.g., '__jkspec')",
      "versioning": "Semantic versioning for the spec format itself",
      "dual_file_architecture": "Framework specs stay in .jkspec/source.json. All user specs MUST live in .jkspec-project/project.json (auto-created on bootstrap).",
      "schema_validation": "Both files validate against .jkspec/jkspec.schema.json using ajv",
      "__meta": {
        "description": "Coding and organizational conventions",
        "goal": "All jkspec conventions documented and enforced by tooling",
        "done": true
      }
    },
    "decisions": [
      {
        "id": "ADR-001",
        "title": "Use single JSON file as source of truth",
        "status": "accepted",
        "date": "2025-12-25",
        "context": "AI agents waste time exploring codebases. Need fast, precise context retrieval.",
        "decision": "Use single .jkspec/source.json file with structured data, queryable via jq",
        "consequences": "Agents get instant context. Must maintain spec alongside code. JSON parsing overhead minimal.",
        "__meta": {
          "description": "Decisions",
          "goal": "ADR-001 documented with context, decision, and consequences",
          "done": true
        }
      },
      {
        "id": "ADR-002",
        "title": "Use object for specs instead of array",
        "status": "accepted",
        "date": "2025-12-25",
        "context": "Need to avoid duplicate keys and enable direct access",
        "decision": "Use object with unique keys for specs: {\"spec-name\": {...}}",
        "consequences": "Direct access via jq '.specs[\"name\"]'. Natural key uniqueness. Slightly more verbose queries for filtering.",
        "__meta": {
          "description": "Decisions",
          "goal": "ADR-002 documented with context, decision, and consequences",
          "done": true
        }
      },
      {
        "id": "ADR-003",
        "title": "Use __ prefix for internal specs",
        "status": "accepted",
        "date": "2025-12-25",
        "context": "Need to distinguish internal jkspec infrastructure from user specs",
        "decision": "Prefix internal/meta specs with __ (double underscore) to clearly mark them as part of jkspec itself",
        "consequences": "Users can easily identify and avoid modifying internal specs. Clear separation of concerns between framework and user content.",
        "__meta": {
          "description": "Decisions",
          "goal": "ADR-003 documented with context, decision, and consequences",
          "done": true
        }
      },
      {
        "id": "ADR-004",
        "title": "Remove CLI abstraction, use jq directly",
        "status": "accepted",
        "date": "2025-12-25",
        "context": "CLI tool adds complexity and maintenance burden. AI agents are fluent in jq. Direct manipulation is more transparent.",
        "decision": "Remove jkspec CLI tool. Use jq directly for all read/write operations on .jkspec/source.json",
        "consequences": "Simpler architecture with fewer moving parts. Agent can see exact jq commands. Users learn standard jq instead of custom CLI. Slightly more verbose operations but more transparent and flexible.",
        "__meta": {
          "description": "Decisions",
          "goal": "ADR-004 documented with context, decision, and consequences",
          "done": true
        }
      },
      {
        "id": "ADR-005",
        "title": "Separate jkspec framework from project specifications using dual-file architecture",
        "status": "accepted",
        "date": "2025-12-25",
        "context": "Users need to update jkspec tooling without affecting their project data. Currently .jkspec/source.json mixes framework specs (__jkspec) with project specs, making updates risky and cumbersome.",
        "decision": "Split into two files: .jkspec/source.json (framework only with __jkspec specs) and .jkspec-project/project.json (user project specs). Both use the same schema. Agents check for .jkspec-project/ on init and create if missing.",
        "consequences": "Users can update jkspec by deleting .jkspec/ and cloning fresh. Project data in .jkspec-project/project.json remains safe. Commands must implement file selection logic based on spec-id prefix. Slightly more complex for agents but much cleaner separation of concerns.",
        "__meta": {
          "description": "Decisions",
          "goal": "ADR-005 documented with context, decision, and consequences",
          "done": true
        }
      }
    ],
    "__meta": {
      "description": "Project-level metadata and configuration",
      "goal": "All child components marked as active",
      "done": true
    }
  },
  "specs": {
    "__jkspec": {
      "__meta": {
        "type": "meta",
        "description": "Internal jkspec system specification - contains all jkspec infrastructure components",
        "tags": [
          "internal",
          "meta",
          "jkspec-system"
        ],
        "note": "This is an internal spec. User specs should not use the __ prefix.",
        "goal": "All child components marked as active",
        "done": true
      },
      "components": {
        "format": {
          "__meta": {
            "type": "specification",
            "description": "The jkspec format itself - structure and conventions",
            "tags": [
              "meta",
              "format"
            ],
            "location": ".jkspec/source.json",
            "goal": "All child components marked as active",
            "done": true,
            "implements": [
              "specs.__jkspec.components.worker",
              "specs.__jkspec.components.cli",
              "specs.__jkspec.components.schema-validation",
              "specs.__jkspec.components.readme-documentation",
              "specs.__jkspec.components.dual-file-architecture"
            ],
            "references": [],
            "validates": "jq \".specs.__jkspec.components.format | .. | objects | select(has(\\\"__meta\\\")) | .__meta | select(has(\\\"done\\\"))\" .jkspec/source.json | jq -s \"length\""
          },
          "structure": {
            "project": {
              "name": "string - project name",
              "description": "string - brief project description",
              "version": "string - semver",
              "architecture": "object - architectural overview",
              "conventions": "object - global coding and organizational conventions",
              "decisions": "array - architectural decision records",
              "__meta": {
                "description": "Project-level metadata and configuration",
                "goal": "Configuration properly defined and documented",
                "done": true
              }
            },
            "specs": {
              "description": "object - keyed by unique spec identifier",
              "spec_schema": {
                "__meta": {
                  "core_fields": {
                    "type": "string - spec type (api, model, component, feature, etc.)",
                    "description": "string - what this spec describes",
                    "tags": "array - searchable tags for filtering and categorization",
                    "done": "boolean - true if goal accomplished, false if pending"
                  },
                  "optional_fields": {
                    "location": "string - file path or directory where this spec is implemented",
                    "purpose": "string - why this spec exists or what problem it solves",
                    "dependencies": "array - list of dependencies (packages, libraries, other specs)",
                    "note": "string - additional notes or warnings about this spec",
                    "complexity": "string - low, medium, high - indicates implementation complexity",
                    "subagent_required": "boolean - true if spec is complex enough to warrant spawning a dedicated subagent for implementation",
                    "implements": "array - spec paths that implement or depend on this spec (downstream dependencies)",
                    "references": "array - spec paths that this spec depends on (upstream dependencies)",
                    "validates": "string - shell command or jq query to validate consistency with implementations"
                  },
                  "description": "All specs must have a __meta object with at minimum the core fields. Optional fields provide additional context and control.",
                  "goal": "Structure defined and documented",
                  "done": true,
                  "implements": [
                    "specs.__jkspec.components.cli.utilities.get_all_pending_source_drafts",
                    "specs.__jkspec.components.cli.utilities.get_all_pending_project_drafts",
                    "specs.__jkspec.components.worker.commands_definitions.implement",
                    "specs.__jkspec.components.worker.status_management"
                  ],
                  "validates": "grep -q '\"status\":' .jkspec/cli/get_all_pending_*.py && echo 'ERROR: CLI scripts still use old status field' || echo 'OK: CLI scripts use done field'"
                },
                "...": "any additional fields relevant to the spec"
              },
              "__meta": {
                "description": "Collection of jkspec specifications",
                "goal": "All child components marked as active",
                "done": true
              }
            },
            "__meta": {
              "description": "Structural definition",
              "goal": "All child components marked as active",
              "done": true,
              "implements": [
                "specs.__jkspec.components.worker.commands_definitions.extend",
                "specs.__jkspec.components.worker.commands_definitions.deepen",
                "specs.__jkspec.components.worker.commands_definitions.implement",
                "specs.__jkspec.components.cli.utilities.get_all_pending_source_drafts",
                "specs.__jkspec.components.cli.utilities.get_all_pending_project_drafts",
                "specs.__jkspec.components.cli.utilities.spec-to-md",
                "specs.__jkspec.components.cli.utilities.make-md-view"
              ],
              "references": [],
              "validates": "jq \".. | objects | select(has(\\\"__meta\\\")) | select(.__meta | has(\\\"description\\\") and has(\\\"done\\\") and has(\\\"goal\\\"))\" .jkspec/source.json | jq -s \"all\""
            }
          },
          "examples": {
            "get_project_info": "jq \".project\" .jkspec/source.json",
            "list_all_specs": "jq \".specs | keys\" .jkspec/source.json",
            "get_specific_spec": "jq \".specs[\\\"spec-name\\\"]\" .jkspec/source.json",
            "get_spec_meta": "jq \".specs[\\\"spec-name\\\"].__meta\" .jkspec/source.json",
            "filter_by_type": "jq \".specs | to_entries[] | select(.value.__meta.type==\\\"api\\\")\" .jkspec/source.json",
            "filter_by_tag": "jq \".specs | to_entries[] | select(.value.__meta.tags[]? == \\\"authentication\\\")\" .jkspec/source.json",
            "filter_by_status": "jq \".specs | to_entries[] | select(.value.__meta.status == \\\"draft\\\")\" .jkspec/source.json",
            "__meta": {
              "description": "Example specifications",
              "goal": "Example provided and working",
              "done": true,
              "implements": [
                "specs.__jkspec.components.readme-documentation"
              ],
              "references": [
                "specs.__jkspec.components.format.structure"
              ]
            }
          },
          "hierarchical_specifications": {
            "description": "Specs can contain nested child specifications at any depth using arbitrary keys",
            "common_keys": [
              "children",
              "specs",
              "tests",
              "endpoints",
              "components",
              "requirements"
            ],
            "status_lifecycle": {
              "__meta": {
                "done": true,
                "description": "Spec completion lifecycle",
                "goal": "Concept documented with examples"
              },
              "done_false": {
                "description": "Specification not yet implemented - goal not accomplished",
                "when_to_use": "Initial spec creation, planning phase, incomplete implementation"
              },
              "done_true": {
                "description": "Specification fully implemented - goal accomplished",
                "when_to_use": "Implementation complete, tests passing, goal achieved"
              },
              "deprecation_policy": {
                "description": "Deprecation is NOT a __meta concern - it belongs in the spec content itself",
                "rationale": "Deprecation pollutes the meta layer. All specs are in use. If documenting deprecated features/functions, add deprecation info to the content, not __meta",
                "example_correct": {
                  "spec_about_auth_methods": {
                    "__meta": {
                      "done": true,
                      "description": "Authentication methods documentation"
                    },
                    "methods": {
                      "session_based": {
                        "deprecated": true,
                        "replacement": "JWT tokens",
                        "reason": "Security concerns with server-side sessions"
                      },
                      "jwt_based": {
                        "current": true
                      }
                    }
                  }
                },
                "example_wrong": {
                  "__meta": {
                    "done": true,
                    "deprecated": true,
                    "description": "Old auth system"
                  }
                }
              },
              "philosophy": "Instead of redoing implementations, refine specs by adding more detailed child specifications to achieve more accurate results. Mark specs as done when their goal is accomplished. Never mark __meta as deprecated."
            },
            "philosophy": "Instead of redoing implementations, refine specs by adding more detailed child specifications to achieve more accurate results",
            "__meta": {
              "description": "Hierarchical specifications",
              "goal": "All child components marked as active",
              "done": true,
              "implements": [
                "specs.__jkspec.components.worker.commands_definitions.deepen",
                "specs.__jkspec.components.depth-system"
              ],
              "references": [
                "specs.__jkspec.components.format.structure"
              ]
            }
          },
          "nested_examples": {
            "simple_nesting": {
              "parent_spec": "__jkspec",
              "child_key": "components",
              "children": {
                "format": {
                  "__meta": {
                    "type": "specification",
                    "description": "The jkspec format specification",
                    "goal": "Example provided and working",
                    "done": true
                  }
                },
                "__meta": {
                  "description": "Children",
                  "goal": "All child components marked as active",
                  "done": true
                }
              },
              "__meta": {
                "description": "Simple nesting",
                "goal": "All child components marked as active",
                "done": true
              }
            },
            "deep_nesting": {
              "description": "Specs can nest arbitrarily deep with each level having its own __meta",
              "example": "auth-api > endpoints > login > validations > email-format",
              "structure": {
                "auth-api": {
                  "__meta": {
                    "type": "api",
                    "description": "Authentication API",
                    "goal": "All child components marked as active",
                    "done": true
                  },
                  "endpoints": {
                    "login": {
                      "__meta": {
                        "type": "endpoint",
                        "description": "Login endpoint",
                        "goal": "All child components marked as active",
                        "done": true
                      },
                      "validations": {
                        "email-format": {
                          "__meta": {
                            "type": "validation",
                            "description": "Email format validation",
                            "goal": "Structure defined and documented",
                            "done": true
                          }
                        },
                        "__meta": {
                          "description": "Validations",
                          "goal": "All child components marked as active",
                          "done": true
                        }
                      }
                    },
                    "__meta": {
                      "description": "Endpoints",
                      "goal": "All child components marked as active",
                      "done": true
                    }
                  }
                },
                "__meta": {
                  "description": "Structural definition",
                  "goal": "All child components marked as active",
                  "done": true
                }
              },
              "__meta": {
                "description": "Deep nesting",
                "goal": "All child components marked as active",
                "done": true
              }
            },
            "__meta": {
              "description": "Nested examples",
              "goal": "All child components marked as active",
              "done": true,
              "implements": [
                "specs.__jkspec.components.readme-documentation"
              ],
              "references": [
                "specs.__jkspec.components.format.hierarchical_specifications",
                "specs.__jkspec.components.format.structure"
              ]
            }
          },
          "jq_editing_examples": {
            "add_new_spec": "jq \".specs[\\\"new-spec-id\\\"] = {__meta: {type: \\\"component\\\", description: \\\"New component\\\", status: \\\"draft\\\", tags: [\\\"frontend\\\"]}}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "update_meta_field": "jq \".specs[\\\"spec-id\\\"].__meta.status = \\\"active\\\"\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "remove_spec": "jq \"del(.specs[\\\"spec-id\\\"])\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "add_nested_child": "jq \".specs[\\\"parent-id\\\"].children[\\\"child-id\\\"] = {__meta: {type: \\\"subcomponent\\\", description: \\\"Child spec\\\", status: \\\"draft\\\"}}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "update_nested_meta": "jq \".specs[\\\"parent-id\\\"].children[\\\"child-id\\\"].__meta.status = \\\"active\\\"\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "add_tag": "jq \".specs[\\\"spec-id\\\"].__meta.tags += [\\\"new-tag\\\"]\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "remove_tag": "jq \".specs[\\\"spec-id\\\"].__meta.tags -= [\\\"old-tag\\\"]\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "add_task": "jq \".specs[\\\"spec-id\\\"].tasks += [{name: \\\"Task name\\\", description: \\\"Task description\\\", done: false}]\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "mark_task_done": "jq \".specs[\\\"spec-id\\\"].tasks[0].done = true\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "update_multiple_meta": "jq \".specs[\\\"spec-id\\\"].__meta |= . + {status: \\\"active\\\", location: \\\"path/to/file\\\"}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "add_data_field": "jq \".specs[\\\"spec-id\\\"].custom_data = {key: \\\"value\\\"}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
            "__meta": {
              "description": "Jq editing examples",
              "goal": "Example provided and working",
              "done": true,
              "implements": [
                "specs.__jkspec.components.worker.jq_operations",
                "specs.__jkspec.components.worker.commands_definitions"
              ],
              "references": [
                "specs.__jkspec.components.format.structure"
              ],
              "validates": "jq \".specs.__jkspec.components.worker.jq_operations | .. | strings | select(test(\\\"jq\\\"))\" .jkspec/source.json | jq -s \"length\""
            }
          },
          "documentation_bindings": {
            "readme_spec": "__jkspec.components.readme-documentation",
            "sections": [
              "what_is_jkspec",
              "core_concepts",
              "examples"
            ],
            "implementation_output": "README.md",
            "update_trigger": "When format spec status is draft, keep readme-documentation in draft until README reflects new structural rules.",
            "rationale": "Format spec defines core structure and jq usage guidance that surface in README sections.",
            "__meta": {
              "description": "Documentation bindings",
              "goal": "All format-to-documentation bindings defined with update triggers",
              "done": true,
              "implements": [
                "specs.__jkspec.components.cli.utilities.spec-to-md",
                "specs.__jkspec.components.cli.utilities.make-md-view",
                "specs.__jkspec.components.readme-documentation"
              ],
              "references": [
                "specs.__jkspec.components.format.structure"
              ],
              "validates": "jq \".specs.__jkspec.components.format.documentation_bindings | has(\\\"triggers\\\") and has(\\\"format\\\")\" .jkspec/source.json"
            }
          },
          "spec_definition": {
            "required_fields": {
              "done": "boolean - false (not implemented) or true (goal accomplished)",
              "description": "string - what this spec describes",
              "goal": "string - completion criteria - what accomplishment means for this spec"
            }
          }
        },
        "depth-system": {
          "__meta": {
            "type": "feature",
            "description": "Single unified agent architecture where jkspec-worker handles all operations from high-level management to detailed implementation",
            "tags": [
              "architecture",
              "unified-agent"
            ],
            "purpose": "Simplified architecture with one agent that can handle any jkspec task",
            "location": ".opencode/agent/",
            "goal": "All child components marked as active",
            "done": true,
            "implements": [],
            "references": [
              "__jkspec.components.format.hierarchical_specifications"
            ],
            "validates": []
          },
          "concepts": {
            "spec_levels": {
              "simple": "Single file, small component, or focused investigation",
              "medium": "Module, service, or feature with multiple files",
              "complex": "System, architecture, or large-scale feature spanning multiple modules",
              "__meta": {
                "description": "Spec levels",
                "goal": "Concept documented with examples",
                "done": true,
                "implements": [
                  "__jkspec.components.worker.commands_definitions.deepen"
                ],
                "references": [
                  "__jkspec.components.format.hierarchical_specifications"
                ],
                "validates": [
                  {
                    "condition": "All spec levels (simple, medium, complex) are defined",
                    "query": "[.specs.__jkspec.components[\"depth-system\"].concepts.spec_levels | has(\"simple\"), has(\"medium\"), has(\"complex\")] | all"
                  }
                ]
              }
            },
            "unified_approach": "Single agent handles both management operations (add/update/validate specs) and implementation work (read/implement/verify specs)",
            "__meta": {
              "description": "Core concepts",
              "goal": "All child components marked as active",
              "done": true,
              "implements": [],
              "references": [
                "__jkspec.components.format.hierarchical_specifications"
              ],
              "validates": [
                {
                  "condition": "All child components have __meta with done status",
                  "query": "[.specs.__jkspec.components[\"depth-system\"].concepts | to_entries[] | select(.key != \"__meta\") | select((.value | type) == \"object\" and (.value | has(\"__meta\")) == false)] | length == 0"
                }
              ]
            }
          },
          "agent_responsibilities": {
            "jkspec-worker": "Handles ALL operations: extends specs, validates structure, analyzes codebase, implements features, explains specs, and verifies implementations"
          },
          "implemented_in": [
            ".opencode/agent/jkspec-worker.md"
          ]
        },
        "worker": {
          "bootstrap": {
            "first_command": "python3 .jkspec/cli/bootstrap.py",
            "description": "On initialization, agent must read the worker object which contains all operational definitions",
            "__meta": {
              "type": "config",
              "description": "Defines initialization steps and first command executed when the worker starts",
              "goal": "Configuration defined and applied",
              "done": true,
              "implements": [],
              "references": [
                "__jkspec.components.cli",
                "__jkspec.components.worker.reading_policy"
              ],
              "validates": [
                {
                  "condition": "Bootstrap command exists",
                  "query": ".specs.__jkspec.components.worker.bootstrap.first_command != null"
                }
              ]
            },
            "context_comparison_strategy": {
              "description": "Protocol for comparing user requests against bootstrap output to determine when deeper context queries are needed",
              "principle": "Bootstrap output contains SUMMARIES intended as navigation aids, not complete operational definitions",
              "workflow": [
                "When user makes a request, compare the request topic against bootstrap output fields",
                "If user request relates to a bootstrap field that shows summary/null/truncated data, recognize this as a signal",
                "The summary is intentionally shallow - worker MUST query deeper into that specific path",
                "Fetch the full detailed specification from source.json using targeted jq queries",
                "Use the detailed spec (not the summary) to fulfill the user request accurately"
              ],
              "examples": {
                "example_1": {
                  "user_request": "How does the implement command work?",
                  "bootstrap_shows": "commands_definitions: null (or brief summary)",
                  "worker_action": "Run: jq .specs.__jkspec.components.worker.commands_definitions.implement .jkspec/source.json",
                  "rationale": "Bootstrap null/summary signals that full definition exists deeper in source.json"
                },
                "example_2": {
                  "user_request": "What are the worker guidelines?",
                  "bootstrap_shows": "guidelines: [array of strings]",
                  "worker_action": "Bootstrap already provided full guidelines array - use it directly",
                  "rationale": "Full data was already loaded, no additional query needed"
                },
                "example_3": {
                  "user_request": "Update the jq_operations safety section",
                  "bootstrap_shows": "jq_operations: null",
                  "worker_action": "Run: jq .specs.__jkspec.components.worker.jq_operations.safety .jkspec/source.json",
                  "rationale": "Need full current state before making modifications"
                }
              },
              "key_indicators": {
                "needs_deeper_query": [
                  "Bootstrap field shows null",
                  "Bootstrap field shows brief string summary instead of full structure",
                  "Bootstrap field shows {\\\"__jq\\\": <number>} indicating nested complexity",
                  "User asks to modify/update a specific subsection",
                  "User asks detailed questions about implementation or behavior"
                ],
                "use_bootstrap_directly": [
                  "Bootstrap field contains complete array or simple value",
                  "User asks general navigation question (\\\"what commands are available?\\\")",
                  "Bootstrap data is sufficient to answer the question"
                ]
              },
              "rationale": "Bootstrap is designed for minimal initial context. Summaries are intentional signals that detailed specs exist and should be fetched on-demand when relevant to user request.",
              "__meta": {
                "description": "Strategy for intelligently expanding context based on user request comparison with bootstrap output",
                "goal": "Enable worker to recognize when bootstrap summaries need expansion via targeted queries",
                "done": true,
                "implements": [],
                "references": [
                  "__jkspec.components.worker.context_management"
                ],
                "validates": []
              }
            },
            "include_full_fields": [
              "guidelines_structured"
            ],
            "rationale": "guidelines_structured contains weighted priority rules critical for first-run behavior - must be loaded immediately, not on-demand",
            "layers": {
              "__meta": {
                "description": "Multi-layer bootstrap system with progressive context loading",
                "goal": "Design documented and ready for implementation",
                "done": true,
                "implements": [],
                "references": [
                  "__jkspec.components.dual-file-architecture",
                  "__jkspec.components.cli"
                ],
                "validates": []
              },
              "description": "Worker uses progressive bootstrap layers - starting with core behavior, then conditionally loading project context based on user command intent",
              "layer_1_core": {
                "name": "Core Worker Bootstrap",
                "trigger": "Always runs on worker initialization",
                "command": "python3 .jkspec/cli/bootstrap.py",
                "target_file": ".jkspec/source.json",
                "target_path": "specs.__jkspec.components.worker",
                "output": "Summary of worker behavior, commands, policies, guidelines",
                "purpose": "Initialize worker with its own operational framework",
                "status": "active"
              },
              "layer_2_project": {
                "name": "Project Principles Bootstrap",
                "trigger": "Conditional - runs when user request involves project specs (not framework specs)",
                "command": "python3 .jkspec/cli/bootstrap_project.py",
                "target_file": ".jkspec-project/project.json",
                "target_path": "project",
                "output": "Summary of project principles, architecture, conventions, goals",
                "purpose": "Load project-specific context before working with user specs",
                "status": "active",
                "conditional_triggers": [
                  "User asks to create/modify project specs (non-__ prefixed)",
                  "User asks about project architecture or conventions",
                  "User runs jkspec-extend without __ prefix",
                  "User runs jkspec-implement on project specs",
                  "User explicitly requests project context"
                ],
                "skip_triggers": [
                  "User working with __ prefixed specs (framework internals)",
                  "User in dev-mode",
                  "User asks general questions not requiring project context"
                ]
              },
              "progressive_depth": {
                "description": "After bootstrapping a layer, worker uses summary output to guide deeper queries",
                "workflow": [
                  "Bootstrap loads summaries for quick context",
                  "Worker compares user request against bootstrap fields",
                  "If request relates to null/summary field, query full details with jq",
                  "Use detailed spec to fulfill request accurately"
                ],
                "example_flow": {
                  "step_1": "User: Create a new authentication spec",
                  "step_2": "Worker detects: project spec creation (non-__ prefix)",
                  "step_3": "Worker runs: python3 .jkspec/cli/bootstrap_project.py",
                  "step_4": "Bootstrap shows: architecture: {summary}, conventions: {summary}",
                  "step_5": "Worker queries: jq .project.conventions.naming .jkspec-project/project.json",
                  "step_6": "Worker uses full conventions to create spec following project patterns"
                }
              },
              "implementation_requirements": {
                "new_cli_script": {
                  "path": ".jkspec/cli/bootstrap_project.py",
                  "purpose": "Bootstrap project principles from project.json",
                  "behavior": "Mirror bootstrap.py but target project.json project object",
                  "output_format": "Summary of project fields (architecture, conventions, goals, etc.)",
                  "auto_create": "If project.json does not exist, create minimal template first"
                },
                "worker_logic": {
                  "detection": "Worker must detect when user request involves project specs vs framework specs",
                  "routing": "Route to layer 2 bootstrap before processing project-related commands",
                  "caching": "Can cache bootstrap results per session to avoid repeated calls"
                }
              }
            }
          },
          "commands_location": ".opencode/command",
          "commands_description": "All jkspec-worker commands are defined as minimal markdown files in .opencode/command/ directory. Each command file references a jq query to fetch the full command definition from .jkspec/source.json at .specs.__jkspec.components.worker.commands_definitions.<command-name>",
          "available_commands": [
            "jkspec-extend",
            "jkspec-deepen",
            "jkspec-implement",
            "jkspec-dev-mode"
          ],
          "reading_policy": {
            "description": "Use jq directly to read and manipulate .jkspec/source.json",
            "philosophy": "Direct JSON manipulation with jq is simpler and more transparent than abstracting behind a CLI tool",
            "common_operations": {
              "read_spec": "jq \".specs[\\\"spec-id\\\"]\" .jkspec/source.json",
              "read_spec_meta": "jq \".specs[\\\"spec-id\\\"].__meta\" .jkspec/source.json",
              "list_specs": "jq \".specs | keys\" .jkspec/source.json",
              "get_worker_config": "jq \".worker\" .jkspec/source.json",
              "get_project_info": "jq \".project\" .jkspec/source.json",
              "filter_by_type": "jq \".specs | to_entries[] | select(.value.__meta.type == \\\"api\\\")\" .jkspec/source.json",
              "filter_by_status": "jq \".specs | to_entries[] | select(.value.__meta.status == \\\"draft\\\")\" .jkspec/source.json",
              "__meta": {
                "description": "Common operations",
                "goal": "Policy defined and documented",
                "done": true,
                "implements": [],
                "references": [
                  "__jkspec.components.worker.jq_operations",
                  "__jkspec.components.cli"
                ],
                "validates": []
              }
            },
            "best_practices": [
              "Always use tmp.json pattern when modifying: jq '...' file.json > tmp.json && mv tmp.json file.json",
              "Validate JSON after modifications with: jq empty .jkspec/source.json",
              "Use --arg for passing variables to avoid shell escaping issues",
              "Use -r flag for raw output when you need unquoted strings",
              "Test complex jq queries with read-only operations first"
            ],
            "__meta": {
              "type": "policy",
              "description": "Explains how the worker reads and modifies specs using jq",
              "goal": "All child components marked as active",
              "done": true,
              "implements": [],
              "references": [
                "__jkspec.components.cli",
                "__jkspec.components.worker.jq_operations"
              ],
              "validates": [
                {
                  "condition": "CLI mandatory flag is boolean",
                  "query": ".specs.__jkspec.components.worker.reading_policy.cli_mandatory | type == \"boolean\""
                }
              ]
            }
          },
          "complex_specs": {
            "description": "How to handle specs with multiple components",
            "approach": [
              "Identify child specs (look for children, specs, tests fields)",
              "Break down work into components",
              "Implement systematically through each component",
              "Track progress and update status fields",
              "Report comprehensively on all components"
            ],
            "__meta": {
              "type": "guideline",
              "description": "Guidance for handling multi-component or deeply nested specifications",
              "goal": "Guidance documented with approach steps and examples",
              "done": true,
              "implements": [],
              "references": [
                "__jkspec.components.worker.workflow",
                "__jkspec.components.worker.incremental_traversal"
              ],
              "validates": []
            }
          },
          "subagent_policy": {
            "description": "When and how jkspec-worker spawns subagents for complex implementation tasks",
            "when_to_spawn": [
              "Spec has subagent_required: true in __meta",
              "Spec has complexity: high and involves significant implementation work",
              "User explicitly requests subagent usage",
              "Implementation involves multiple files or coordinated changes",
              "Task requires sustained focus beyond simple edits"
            ],
            "how_to_spawn": {
              "use_task_tool": "Use the Task tool to spawn general-purpose subagent",
              "provide_full_spec": "Pass complete spec details to subagent including all requirements, tasks, and constraints",
              "clear_instructions": "Give subagent explicit instructions on what to implement and how to verify correctness",
              "result_reporting": "Subagent should report back implementation status and any issues encountered",
              "__meta": {
                "description": "How to spawn",
                "goal": "Policy defined and documented",
                "done": true,
                "implements": [],
                "references": [
                  "__jkspec.components.worker.subagent_policy"
                ],
                "validates": []
              }
            },
            "worker_responsibilities": [
              "Read and understand spec before spawning subagent",
              "Determine if subagent is needed based on complexity",
              "Prepare comprehensive prompt for subagent with all necessary context",
              "Monitor subagent work and integrate results",
              "Update spec status and tasks array after subagent completes work"
            ],
            "example_workflow": "1. Read spec with jq\n2. Check complexity and subagent_required fields\n3. If needed, use Task tool to spawn subagent with full spec context\n4. Subagent implements according to spec requirements\n5. Worker verifies implementation and updates spec status",
            "__meta": {
              "type": "policy",
              "description": "Rules for when and how the worker should spawn subagents",
              "goal": "All child components marked as active",
              "done": true,
              "implements": [],
              "references": [
                "__jkspec.components.worker.commands_definitions.implement",
                "__jkspec.components.worker.complex_specs"
              ],
              "validates": []
            }
          },
          "greeting": {
            "style": "minimal",
            "message": "Initialized and ready.",
            "include_commands_list": false,
            "rationale": "Keep greeting concise - user can ask for help if needed",
            "__meta": {
              "type": "behavior",
              "description": "Defines the greeting tone, message, and rationale for user interactions",
              "goal": "Configuration defined and applied",
              "done": true,
              "implements": [],
              "references": [],
              "validates": []
            },
            "description": "Defines greeting style, message, and rationale"
          },
          "commands_definitions": {
            "extend": {
              "description": "Add a new spec to the appropriate jkspec file",
              "steps": [
                "Determine target file: If spec-id starts with __, use .jkspec/source.json (framework), otherwise use .jkspec-project/project.json (user project)",
                "Check if .jkspec-project/project.json exists, create with minimal template if needed for user specs",
                "Validate the spec-id follows kebab-case convention",
                "Check if spec already exists: jq \".specs[\\\"<spec-id>\\\"]\" <target-file>",
                "Use jq to add the spec with __meta object (REQUIRED: type, status=draft, description) and any requested fields or child components. All nested components must also have __meta with status.",
                "Validate: Run bash .jkspec/tests/schema-validation/run_tests.sh to ensure both files are valid",
                "Confirm success and show the added spec: jq \".specs[\\\"<spec-id>\\\"]\" <target-file>"
              ],
              "__meta": {
                "description": "Extend",
                "goal": "Command fully defined with steps and examples",
                "done": true,
                "implements": [
                  "__jkspec.components.worker.commands.jkspec-extend"
                ],
                "references": [
                  "__jkspec.components.format",
                  "__jkspec.components.worker.jq_operations.writing"
                ],
                "validates": []
              }
            },
            "deepen": {
              "description": "Transform a shallow spec into a richer hierarchy by adding detailed child specs, tasks, or metadata",
              "steps": [
                "Identify the target spec and determine source file based on prefix",
                "Read current spec structure incrementally to understand existing __meta, children, and tasks",
                "Work with the user to pinpoint which areas need deeper coverage (e.g., break out children, add tasks, capture locations/dependencies)",
                "Add or update nested child specs or array items, ENSURING each has a __meta object with explicit status (draft or active). Parent spec status should remain draft if any children are draft.",
                "Augment traceability fields (tasks array, dependencies, notes) to reflect the new depth",
                "Update relevant statuses/tags if the spec maturity changes",
                "Validate the modified file and show the updated portion of the spec"
              ],
              "deepening_patterns": [
                "Split high-level specs into child specs for each subsystem",
                "Add validation/test children for APIs",
                "Use tasks array to document implementation steps",
                "Attach location/dependency metadata for each new child"
              ],
              "__meta": {
                "description": "Deepen",
                "goal": "Command fully defined with steps and examples",
                "done": true,
                "implements": [
                  "__jkspec.components.worker.commands.jkspec-deepen"
                ],
                "references": [
                  "__jkspec.components.worker.context_management",
                  "__jkspec.components.worker.jq_operations.reading"
                ],
                "validates": []
              }
            },
            "implement": {
              "description": "Review all draft specs, analyze task structure, suggest optimal worker allocation, and drive parallel or sequential implementation to completion",
              "steps": [
                "Discover all pending drafts using get_all_pending_source_drafts.py and get_all_pending_project_drafts.py",
                "Sort results by JSON path length (longest first) to prioritize most specific tasks",
                "Analyze task tree structure to identify independent branches suitable for parallel execution",
                "Calculate and present suggested optimal worker count with rationale based on task structure",
                "Wait for user confirmation on worker count and task allocation strategy",
                "If multi-worker confirmed: delegate entire task trees to parallel jkspec-worker agents via Task tool",
                "If single-worker: select most specific draft and proceed with implementation",
                "Each worker (or single worker) reads assigned spec in detail, noting nested tasks and dependencies",
                "Each worker executes implementation plan (code changes, tests, docs) or spawns subagents if needed",
                "Each worker updates spec status from draft to active. CHECK: all child components must be active before marking parent active",
                "Each worker propagates status upward through tree when children complete",
                "Validate edited spec files against schema",
                "Aggregate and summarize implementation outcomes from all workers"
              ],
              "draft_discovery": {
                "description": "Use CLI tools to find all pending drafts across both files",
                "source_command": "python3 .jkspec/cli/get_all_pending_source_drafts.py",
                "project_command": "python3 .jkspec/cli/get_all_pending_project_drafts.py",
                "sorting": "Sort by path length descending - longest paths (most specific tasks) come first",
                "rationale": "Leaf-node tasks are more concrete and easier to implement, building toward parent specs",
                "__meta": {
                  "description": "Draft discovery",
                  "goal": "Command fully defined with steps and examples",
                  "done": true,
                  "implements": [],
                  "references": [
                    "__jkspec.components.traceability",
                    "__jkspec.components.worker.jq_operations.advanced.list_draft_paths"
                  ],
                  "validates": []
                }
              },
              "task_pattern": {
                "description": "Any object with __meta.status=draft is a task to be implemented",
                "examples": [
                  "Top-level spec with status=draft",
                  "Nested array item with __meta.status=draft (e.g., implementation_steps, requirements, test_cases)",
                  "Child component with status=draft"
                ],
                "flexibility": "Tasks can live anywhere in the spec tree - no specific field name required",
                "discovery": "The get_all_pending_drafts commands find all draft objects regardless of location",
                "__meta": {
                  "description": "Task pattern",
                  "goal": "Command fully defined with steps and examples",
                  "done": true,
                  "implements": [],
                  "references": [
                    "__jkspec.components.traceability",
                    "__jkspec.components.worker.spec_definition"
                  ],
                  "validates": []
                }
              },
              "__meta": {
                "type": "command",
                "description": "Command definition for implementing draft specs using longest-path-first strategy",
                "goal": "All child components marked as active",
                "done": true,
                "implements": [
                  "__jkspec.components.worker.commands.jkspec-implement"
                ],
                "references": [
                  "__jkspec.components.traceability",
                  "__jkspec.components.worker.status_management",
                  "__jkspec.components.worker.jq_operations.advanced.list_draft_paths"
                ],
                "validates": []
              },
              "worker_delegation": {
                "description": "Strategy for delegating task trees to multiple parallel workers",
                "workflow": [
                  "After discovering and displaying all pending drafts, analyze the task tree structure",
                  "Identify independent task branches that can be parallelized (separate specs or major subtrees)",
                  "Calculate optimal worker count based on analysis factors",
                  "Present suggested worker allocation to user with clear rationale",
                  "Wait for user confirmation or adjustment of worker count",
                  "Delegate entire task trees to parallel workers or proceed with single-worker implementation"
                ],
                "worker_count_analysis": {
                  "factors": [
                    "Number of independent task branches (top-level specs or major subtrees)",
                    "Task complexity (deep nested structures vs flat tasks)",
                    "Total task count",
                    "Task interdependencies (prefer independent branches for parallelization)"
                  ],
                  "heuristics": {
                    "single_worker": "1-3 tasks OR highly interdependent tasks",
                    "two_workers": "4-8 tasks with 2 independent branches",
                    "three_workers": "9-15 tasks with 3+ independent branches",
                    "four_plus_workers": "16+ tasks with 4+ independent branches"
                  }
                },
                "delegation_strategy": {
                  "approach": "Assign entire task trees (root spec + all children) to individual workers",
                  "benefits": [
                    "Parallel execution reduces total time",
                    "Each worker maintains full context for their tree",
                    "Independent validation per worker",
                    "Reduced risk of merge conflicts when working on separate specs"
                  ],
                  "coordination": "Main worker aggregates results and reports final status from all parallel workers"
                },
                "user_confirmation": {
                  "required": true,
                  "format": "Present: (1) List of all pending drafts grouped by branch, (2) Suggested worker count with rationale, (3) Proposed task allocation per worker",
                  "wait_for": "User to confirm worker count or request adjustment before proceeding with delegation"
                },
                "__meta": {
                  "description": "Multi-worker delegation strategy for parallel implementation",
                  "goal": "Enable parallel task execution for faster implementation of independent specs",
                  "done": true,
                  "implements": [],
                  "references": [
                    "__jkspec.components.worker.subagent_policy"
                  ],
                  "validates": []
                }
              }
            },
            "dev-mode": {
              "description": "Enter focused developer mode for modifying internal specs, defined as any component nested under __jkspec (i.e., __ prefixed jkspec infrastructure specs)",
              "steps": [
                "Confirm intent to edit internal specs and review modification_policy guidance",
                "List relevant __ prefixed specs to scope the work using jq '.specs.__jkspec.components | keys' .jkspec/source.json",
                "Load the necessary internal spec sections (e.g., worker object, commands, guidelines)",
                "Plan the required changes, capturing affected commands/guidelines before editing",
                "Apply updates using jq, keeping changes scoped to .jkspec/source.json",
                "Validate the file immediately after edits and report the internal spec adjustments"
              ],
              "dev_mode_principles": [
                "Only edit __ prefixed specs while in this mode",
                "Reference modification_policy expectations before changing internal behavior",
                "Document rationale for internal changes in the response",
                "Never query or access project specs (.jkspec-project/project.json) while in dev-mode; limit interactions strictly to internal __-prefixed specs."
              ],
              "__meta": {
                "description": "Dev mode",
                "goal": "Command fully defined with steps and examples",
                "done": true,
                "implements": [
                  "__jkspec.components.worker.commands.jkspec-dev-mode"
                ],
                "references": [
                  "__jkspec.components.worker.modification_policy",
                  "__jkspec.components.impact-tracking"
                ],
                "validates": []
              }
            },
            "__meta": {
              "type": "reference",
              "description": "Detailed definitions, steps, and principles for each worker command",
              "goal": "All child components marked as active",
              "done": true,
              "implements": [],
              "references": [
                "__jkspec.components.format",
                "__jkspec.components.worker.jq_operations",
                "__jkspec.components.dual-file-architecture"
              ],
              "validates": [
                {
                  "condition": "All commands have __meta",
                  "query": "[.specs.__jkspec.components.worker.commands_definitions | to_entries[] | select(.key != \"__meta\") | select(.value.__meta == null)] | length == 0"
                }
              ]
            },
            "description": "Step-by-step definitions for each worker command",
            "validate": {
              "command": "jkspec-validate",
              "purpose": "Validate jkspec JSON files against the JSON schema",
              "description": "Validates both source.json and project.json against jkspec.schema.json using ajv",
              "steps": [
                {
                  "step": 1,
                  "action": "Validate source.json",
                  "command": "bash .jkspec/tests/schema-validation/run_tests.sh",
                  "description": "Validate framework specifications file"
                },
                {
                  "step": 2,
                  "action": "Check if project.json exists",
                  "command": "test -f .jkspec-project/project.json",
                  "description": "Check if user project file exists"
                },
                {
                  "step": 4,
                  "action": "Report results",
                  "description": "Show validation status for both files"
                }
              ],
              "usage": "jkspec-validate [file]",
              "parameters": {
                "file": "Optional: specific file to validate (source.json or project.json). If omitted, validates both."
              },
              "outputs": [
                "Validation success/failure for source.json",
                "Validation success/failure for project.json (if exists)"
              ],
              "__meta": {
                "description": "Validate command definition",
                "done": true,
                "implements": [
                  "__jkspec.components.worker.commands.jkspec-validate"
                ],
                "references": [
                  "__jkspec.components.format",
                  "__jkspec.components.cli"
                ],
                "validates": []
              }
            }
          },
          "__meta": {
            "type": "agent",
            "description": "Unified agent for managing and implementing jkspec specifications - handles both high-level management operations and detailed implementation work",
            "tags": [
              "ai-agents",
              "management",
              "implementation"
            ],
            "purpose": "Single agent that can extend, validate, maintain jkspec files AND read/implement individual specs using jq directly",
            "location": ".opencode/agent/jkspec-worker.md",
            "dependencies": [
              "jq"
            ],
            "goal": "All child components marked as active",
            "done": true,
            "implements": [],
            "references": [
              "__jkspec.components.format",
              "__jkspec.components.cli",
              "__jkspec.components.traceability",
              "__jkspec.components.impact-tracking",
              "__jkspec.components.dual-file-architecture"
            ],
            "validates": [
              {
                "condition": "All child components are done",
                "query": "[.specs.__jkspec.components.worker | .. | .__meta? | select(. != null) | select(.done == false)] | length == 0"
              }
            ]
          },
          "capabilities": {
            "management": [
              "Extend specs by adding new child components",
              "Deepen specs by adding detail to existing components",
              "Modify internal worker behavior via dev-mode"
            ],
            "implementation": [
              "Implement specs according to requirements",
              "Work with complex multi-component specs"
            ],
            "__meta": {
              "type": "reference",
              "description": "Catalog of management and implementation capabilities exposed by the worker",
              "goal": "All worker capabilities cataloged in management and implementation lists",
              "done": true,
              "implements": [],
              "references": [
                "__jkspec.components.worker.commands_definitions",
                "__jkspec.components.worker.workflow"
              ],
              "validates": []
            },
            "description": "Summary of management and implementation capabilities"
          },
          "commands": {
            "extend": "Add new child components to a spec",
            "deepen": "Add detail to existing spec components",
            "implement": "Turn draft specs into implementations",
            "dev-mode": "Inspect and modify worker behavior for internal specs",
            "__meta": {
              "type": "reference",
              "description": "Mapping of command names to their functional purpose",
              "goal": "All available commands mapped to their functional descriptions",
              "done": true,
              "implements": [],
              "references": [
                "__jkspec.components.worker.commands_definitions"
              ],
              "validates": [
                {
                  "condition": "All commands have definitions",
                  "query": "[.specs.__jkspec.components.worker.commands | to_entries[] | select(.key != \"__meta\") | .key as $cmd | select(($cmd | gsub(\"^jkspec-\"; \"\")) as $name | .specs.__jkspec.components.worker.commands_definitions[$name] == null)] | length == 0"
                }
              ]
            },
            "description": "Maps command names to their high-level purposes"
          },
          "jq_operations": {
            "reading": {
              "get_spec": "jq \".specs[\\\"spec-id\\\"]\" .jkspec/source.json",
              "get_spec_meta": "jq \".specs[\\\"spec-id\\\"].__meta\" .jkspec/source.json",
              "get_nested_spec": "jq \".specs[\\\"parent-id\\\"].children[\\\"child-id\\\"]\" .jkspec/source.json",
              "get_nested_meta": "jq \".specs[\\\"parent-id\\\"].children[\\\"child-id\\\"].__meta\" .jkspec/source.json",
              "list_all_specs": "jq \".specs | keys\" .jkspec/source.json",
              "list_specs_by_type": "jq \".specs | to_entries[] | select(.value.__meta.type == \\\"api\\\") | .key\" .jkspec/source.json",
              "list_specs_by_tag": "jq \".specs | to_entries[] | select(.value.__meta.tags[]? == \\\"backend\\\") | .key\" .jkspec/source.json",
              "get_all_draft_specs": "jq \".specs | to_entries[] | select(.value.__meta.status == \\\"draft\\\")\" .jkspec/source.json",
              "get_project_info": "jq \".project\" .jkspec/source.json",
              "__meta": {
                "description": "Reading",
                "goal": "Operations documented with examples",
                "done": true,
                "implements": [],
                "references": [
                  "__jkspec.components.worker.reading_policy"
                ],
                "validates": []
              }
            },
            "writing": {
              "add_spec": "jq \".specs[\\\"new-spec\\\"] = {__meta: {type: \\\"component\\\", description: \\\"Description\\\", status: \\\"draft\\\", tags: []}}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "update_meta_field": "jq \".specs[\\\"spec-id\\\"].__meta.status = \\\"active\\\"\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "add_data_field": "jq \".specs[\\\"spec-id\\\"].new_field = \\\"value\\\"\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "add_nested_spec": "jq \".specs[\\\"parent\\\"].children[\\\"child\\\"] = {__meta: {type: \\\"type\\\", description: \\\"desc\\\", status: \\\"draft\\\"}}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "add_tag": "jq \".specs[\\\"spec-id\\\"].__meta.tags += [\\\"new-tag\\\"]\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "update_multiple_meta": "jq \".specs[\\\"spec-id\\\"].__meta |= . + {status: \\\"active\\\", location: \\\"path/to/file\\\"}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "__meta": {
                "description": "Writing",
                "goal": "Operations documented with examples",
                "done": true,
                "implements": [],
                "references": [
                  "__jkspec.components.format",
                  "__jkspec.components.dual-file-architecture"
                ],
                "validates": []
              }
            },
            "deleting": {
              "remove_spec": "jq \"del(.specs[\\\"spec-id\\\"])\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "remove_nested": "jq \"del(.specs[\\\"parent\\\"].children[\\\"child\\\"])\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "remove_data_field": "jq \"del(.specs[\\\"spec-id\\\"].field_name)\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "remove_tag": "jq \".specs[\\\"spec-id\\\"].__meta.tags -= [\\\"tag-to-remove\\\"]\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "remove_meta_field": "jq \"del(.specs[\\\"spec-id\\\"].__meta.field_name)\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "__meta": {
                "description": "Deleting",
                "goal": "Operations documented with examples",
                "done": true,
                "implements": [],
                "references": [
                  "__jkspec.components.format",
                  "__jkspec.components.impact-tracking"
                ],
                "validates": []
              }
            },
            "advanced": {
              "conditional_update": "jq \".specs |= with_entries(if .value.__meta.status == \\\"draft\\\" then .value.__meta.status = \\\"reviewed\\\" else . end)\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "bulk_add_meta_field": "jq \".specs |= with_entries(.value.__meta.updated = \\\"2025-12-25\\\")\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "deep_merge_data": "jq \".specs[\\\"spec-id\\\"] |= . * {new_field: \\\"value\\\", nested: {key: \\\"val\\\"}}\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "filter_and_rebuild": "jq \".specs |= with_entries(select(.value.__meta.status != \\\"deprecated\\\"))\" .jkspec/source.json > tmp.json && mv tmp.json .jkspec/source.json",
              "list_draft_paths": {
                "description": "List dot-delimited JSON paths for every draft spec",
                "project_command": "jq -r \"paths(objects | select(has(\\\"__meta\\\") and .__meta.status == \\\"draft\\\")) | map(tostring) | join(\\\".\\\")\" .jkspec-project/project.json",
                "dev_mode_command": "jq -r \"paths(objects | select(has(\\\"__meta\\\") and .__meta.status == \\\"draft\\\")) | select(.[0] == \\\"specs\\\" and .[1] == \\\"__jkspec\\\") | map(tostring) | join(\\\".\\\")\" .jkspec/source.json",
                "usage_notes": "Always run the project command first (covers user specs). Only run the dev mode command when explicitly working on __ prefixed internal specs inside source.json.",
                "__meta": {
                  "description": "List draft paths",
                  "goal": "Operations documented with examples",
                  "done": true,
                  "implements": [],
                  "references": [
                    "__jkspec.components.traceability",
                    "__jkspec.components.worker.spec_definition"
                  ],
                  "validates": []
                }
              },
              "__meta": {
                "description": "Advanced",
                "goal": "All child components marked as active",
                "done": true,
                "implements": [],
                "references": [
                  "__jkspec.components.traceability"
                ],
                "validates": []
              }
            },
            "__meta": {
              "type": "reference",
              "description": "Library of jq snippets for reading and editing specs",
              "goal": "All child components marked as active",
              "done": true,
              "implements": [],
              "references": [
                "__jkspec.components.cli",
                "__jkspec.components.format"
              ],
              "validates": [
                {
                  "condition": "All operation categories have __meta",
                  "query": "[.specs.__jkspec.components.worker.jq_operations | to_entries[] | select(.key != \"__meta\") | select(.value.__meta == null)] | length == 0"
                }
              ]
            },
            "description": "Library of jq snippets for reading, writing, deleting, and advanced operations",
            "safety": {
              "description": "Critical patterns to avoid data loss when modifying JSON files",
              "safe_patterns": {
                "single_update": {
                  "pattern": "jq \".path.to.field = value\" file.json > /tmp/updated.json && mv /tmp/updated.json file.json",
                  "explanation": "Updates one field and returns the FULL modified JSON"
                },
                "multiple_updates": {
                  "pattern": "jq \".path1 = val1 | .path2 = val2\" file.json > /tmp/updated.json && mv /tmp/updated.json file.json",
                  "explanation": "Chain multiple assignments with pipes, returns FULL JSON"
                },
                "nested_object_creation": {
                  "pattern": "jq \".specs.worker.new_section = {field1: \"val1\", field2: \"val2\"}\" file.json > /tmp/updated.json && mv /tmp/updated.json file.json",
                  "explanation": "Creates nested objects safely"
                }
              },
              "dangerous_patterns": {
                "pipe_with_selection": {
                  "pattern": "jq \".path = value | .path\" file.json",
                  "problem": "The final | .path SELECTS only that path, discarding the rest of the JSON!",
                  "result": "Entire file replaced with just that fragment",
                  "fix": "Remove the | .path at the end"
                },
                "selection_after_update": {
                  "pattern": "jq \".specs.worker.field = value | .specs.worker\" file.json",
                  "problem": "Returns only .specs.worker instead of full JSON",
                  "result": "File becomes just the worker object, losing everything else",
                  "fix": "Never pipe to a selector after assignment"
                }
              },
              "validation_checkpoint": {
                "rule": "After ANY modification to source.json or project.json, IMMEDIATELY validate against schema",
                "command": "bash .jkspec/tests/schema-validation/run_tests.sh",
                "rationale": "Catches structural errors before they compound"
              },
              "__meta": {
                "description": "Safety guidelines for jq operations to prevent data loss",
                "goal": "Prevent destructive jq patterns that can corrupt JSON files",
                "done": true,
                "implements": [],
                "references": [
                  "__jkspec.components.worker.reading_policy"
                ],
                "validates": []
              }
            }
          },
          "workflow": {
            "description": "Worker follows a consultative approach when helping users implement new specs",
            "new_spec_creation": {
              "phase_1_gather_requirements": {
                "description": "Before writing any spec, worker asks clarifying questions to understand all details",
                "questions_to_ask": [
                  "What is the spec ID (kebab-case)?",
                  "What type is this spec (api, component, model, feature, etc.)?",
                  "What is the purpose/description of this spec?",
                  "What files/locations will be affected?",
                  "Are there any dependencies or related specs?",
                  "What tags should be applied?",
                  "Should this include a tasks array for traceability?",
                  "Are there nested child specs or components?",
                  "What is the expected behavior or implementation details?"
                ],
                "approach": "Ask questions conversationally, not as a checklist. Adapt based on user responses and spec type.",
                "goal": "Gather complete understanding before proposing any spec structure",
                "__meta": {
                  "description": "Phase 1 gather requirements",
                  "goal": "Rationale clearly documented and reviewed",
                  "done": true,
                  "implements": [],
                  "references": [
                    "__jkspec.components.worker.workflow.new_spec_creation"
                  ],
                  "validates": []
                }
              },
              "phase_2_propose_draft": {
                "description": "Once all details are clear, propose a complete draft spec structure",
                "actions": [
                  "Show the proposed JSON structure to the user",
                  "Explain the structure and any design decisions",
                  "Ask for confirmation or adjustments"
                ],
                "__meta": {
                  "description": "Phase 2 propose draft",
                  "goal": "Rationale clearly documented and reviewed",
                  "done": true,
                  "implements": [],
                  "references": [
                    "__jkspec.components.format"
                  ],
                  "validates": []
                }
              },
              "phase_3_write_spec": {
                "description": "After user approval, write the spec to source.json",
                "actions": [
                  "Use jq to add the spec with status: draft",
                  "Validate the JSON structure",
                  "Confirm successful creation",
                  "Show the final spec to the user"
                ],
                "__meta": {
                  "description": "Phase 3 write spec",
                  "goal": "Rationale clearly documented and reviewed",
                  "done": true,
                  "implements": [],
                  "references": [
                    "__jkspec.components.worker.jq_operations.writing",
                    "__jkspec.components.dual-file-architecture"
                  ],
                  "validates": []
                }
              },
              "__meta": {
                "description": "New spec creation",
                "goal": "All child components marked as active",
                "done": true,
                "implements": [],
                "references": [
                  "__jkspec.components.format",
                  "__jkspec.components.dual-file-architecture"
                ],
                "validates": [
                  {
                    "condition": "All phases are done",
                    "query": "[.specs.__jkspec.components.worker.workflow.new_spec_creation | to_entries[] | select(.key | startswith(\"phase_\")) | select(.value.__meta.done == false)] | length == 0"
                  }
                ]
              }
            },
            "philosophy": "Measure twice, cut once - thorough understanding before implementation prevents rework",
            "__meta": {
              "type": "process",
              "description": "Prescribed workflow for creating and updating specs",
              "goal": "All child components marked as active",
              "done": true,
              "implements": [],
              "references": [
                "__jkspec.components.format",
                "__jkspec.components.worker.context_management",
                "__jkspec.components.worker.status_management"
              ],
              "validates": []
            }
          },
          "context_management": {
            "description": "Strategy for querying JSON specs to maintain efficient context usage",
            "principles": [
              "Query first level of depth for broad context awareness",
              "Include worker context itself in initial bootstrap",
              "Dynamically extend context selectively based on actual needs",
              "Avoid loading large nested JSON objects upfront"
            ],
            "bootstrap_queries": {
              "worker_config": "jq '.worker' .jkspec/source.json",
              "project_overview": "jq '.project' .jkspec/source.json",
              "spec_list": "jq '.specs | keys' .jkspec/source.json",
              "spec_first_level": "jq '.specs | with_entries(.value |= {__meta})' .jkspec/source.json",
              "__meta": {
                "description": "Bootstrap queries",
                "goal": "Bootstrap logic implemented and tested",
                "done": true,
                "implements": [],
                "references": [
                  "__jkspec.components.cli",
                  "__jkspec.components.worker.bootstrap"
                ],
                "validates": []
              }
            },
            "selective_deepening": {
              "description": "Only query deeper levels when specific information is needed",
              "examples": {
                "when_needed": "User asks to implement a specific spec",
                "query_pattern": "jq '.specs[\"specific-spec\"]' .jkspec/source.json",
                "nested_when_needed": "jq '.specs[\"parent\"].children[\"child\"]' .jkspec/source.json",
                "__meta": {
                  "description": "Example specifications",
                  "goal": "Example provided and working",
                  "done": true,
                  "implements": [],
                  "references": [
                    "__jkspec.components.worker.context_management.selective_deepening"
                  ],
                  "validates": []
                }
              },
              "__meta": {
                "description": "Selective deepening",
                "goal": "All child components marked as active",
                "done": true,
                "implements": [],
                "references": [
                  "__jkspec.components.worker.incremental_traversal",
                  "__jkspec.components.worker.jq_operations.reading"
                ],
                "validates": []
              }
            },
            "rationale": "Maintains efficient context window usage by loading only necessary information. Worker starts with high-level overview and drills down selectively rather than loading entire nested structures.",
            "__meta": {
              "type": "policy",
              "description": "Strategy for incremental context gathering and selective deepening",
              "goal": "All child components marked as active",
              "done": true,
              "implements": [],
              "references": [
                "__jkspec.components.worker.bootstrap",
                "__jkspec.components.worker.incremental_traversal"
              ],
              "validates": []
            }
          },
          "modification_policy": {
            "description": "Guidelines for modifying worker behavior and understanding impact scope",
            "json_modifications": {
              "scope": "Changes to worker object in .jkspec/source.json",
              "impact": "Does NOT require CLI agent tooling reset",
              "reason": "Worker recontextualizes itself dynamically by reading worker object on bootstrap",
              "examples": [
                "Adding new guidelines",
                "Modifying commands list",
                "Updating policies",
                "Adding workflow steps",
                "Changing context management strategy"
              ],
              "agent_behavior": "Worker reads .worker on initialization via bootstrap command, so changes take effect immediately on next invocation",
              "__meta": {
                "description": "Json modifications",
                "goal": "Structure defined and documented",
                "done": true,
                "implements": [],
                "references": [
                  "__jkspec.components.impact-tracking",
                  "__jkspec.components.format"
                ],
                "validates": []
              }
            },
            "agent_file_modifications": {
              "scope": "Changes to .opencode/agent/jkspec-worker.md agent definition file",
              "impact": "REQUIRES full reset of CLI agent tooling",
              "reason": "Agent file defines core agent initialization, tools, and system prompts that are loaded by CLI at startup",
              "examples": [
                "Modifying agent system prompt",
                "Changing bootstrap instructions",
                "Updating tool access patterns",
                "Altering core agent behavior"
              ],
              "reset_procedure": "Restart or reinitialize the CLI agent tooling to reload the agent definition file",
              "__meta": {
                "description": "Agent file modifications",
                "goal": "Policy defined and documented",
                "done": true,
                "implements": [],
                "references": [
                  "__jkspec.components.impact-tracking"
                ],
                "validates": []
              }
            },
            "command_file_modifications": {
              "scope": "Changes to individual command files in .opencode/commands/",
              "impact": "Does NOT require CLI reset (similar to JSON modifications)",
              "reason": "Command files are read dynamically when commands are invoked",
              "note": "Worker reads command markdown files on-demand when executing specific commands",
              "__meta": {
                "description": "Command file modifications",
                "goal": "Policy defined and documented",
                "done": true,
                "implements": [],
                "references": [
                  "__jkspec.components.impact-tracking"
                ],
                "validates": []
              }
            },
            "best_practice": "Prefer modifying worker JSON object for behavioral changes to avoid needing CLI resets. Reserve agent file modifications for fundamental structural changes.",
            "__meta": {
              "type": "policy",
              "description": "Guidance for editing worker JSON, agent files, and command files",
              "goal": "All child components marked as active",
              "done": true,
              "implements": [],
              "references": [
                "__jkspec.components.impact-tracking",
                "__jkspec.components.worker.reading_policy"
              ],
              "validates": []
            }
          },
          "incremental_traversal": {
            "commandment": "ALWAYS use incremental queries when exploring specs. Start with keys only, then drill down to specific fields as needed. Never read entire large objects unnecessarily.",
            "rationale": "Efficiency and clarity - only fetch data you actually need at each step",
            "approach": [
              "Step 1: List keys to understand structure",
              "Step 2: Check existence or filter by metadata",
              "Step 3: Fetch specific fields or nested keys as needed",
              "Step 4: Only read full objects when absolutely necessary"
            ],
            "examples": {
              "explore_spec": [
                "jq \".specs | keys\" - First see what specs exist",
                "jq \".specs | has(\\\"spec-id\\\")\" - Check if specific spec exists",
                "jq \".specs[\\\"spec-id\\\"] | keys\" - See structure of spec",
                "jq \".specs[\\\"spec-id\\\"].__meta\" - Get metadata",
                "jq \".specs[\\\"spec-id\\\"].specific_field\" - Get specific field only"
              ],
              "explore_nested": [
                "jq \".specs[\\\"parent\\\"].children | keys\" - List child specs",
                "jq \".specs[\\\"parent\\\"].children[\\\"child\\\"] | keys\" - See child structure",
                "jq \".specs[\\\"parent\\\"].children[\\\"child\\\"].__meta.status\" - Get specific nested field"
              ],
              "__meta": {
                "description": "Example specifications",
                "goal": "Example provided and working",
                "done": true,
                "implements": [],
                "references": [
                  "__jkspec.components.worker.incremental_traversal"
                ],
                "validates": []
              }
            },
            "anti_patterns": [
              "Reading entire .specs object when you only need keys",
              "Fetching full spec when you only need to check existence",
              "Getting all fields when you only need __meta",
              "Reading large nested structures when you only need to know what keys exist"
            ],
            "__meta": {
              "type": "guideline",
              "description": "Instructions for incremental exploration of specs and avoiding anti-patterns",
              "goal": "All child components marked as active",
              "done": true,
              "implements": [],
              "references": [
                "__jkspec.components.worker.jq_operations.reading",
                "__jkspec.components.worker.context_management"
              ],
              "validates": []
            },
            "description": "Protocol for incrementally traversing spec trees efficiently"
          },
          "documentation_bindings": {
            "produces": [
              "README.md"
            ],
            "documentation_specs": [
              "__jkspec.components.readme-documentation"
            ],
            "responsibilities": [
              "Mark readme-documentation.__meta.status = \"draft\" when any referenced meta-spec is modified",
              "Regenerate README.md from template before reactivating readme-documentation"
            ],
            "automation_hooks": {
              "validation": "jkspec-validate checks if readme-documentation status is draft and emits reminder to regenerate README",
              "implementation": "jkspec-implement readme-documentation executes README regeneration steps"
            },
            "__meta": {
              "type": "guideline",
              "description": "Rules for documentation outputs, bindings, and automation hooks",
              "goal": "Rule implemented and enforced",
              "done": true,
              "implements": [],
              "references": [
                "__jkspec.components.cli",
                "__jkspec.components.worker.view_inspection"
              ],
              "validates": []
            },
            "description": "Rules connecting specs to documentation outputs and automation hooks"
          },
          "view_inspection": {
            "__meta": {
              "type": "guideline",
              "tags": [
                "worker",
                "inspection",
                "cli"
              ],
              "created": "2025-12-26T05:51:56Z",
              "updated": "2025-12-26T05:51:56Z",
              "description": "Ensure workers generate Markdown inspection views for every new or updated spec using the dedicated CLI tool",
              "goal": "All child components marked as active",
              "done": true,
              "implements": [],
              "references": [
                "__jkspec.components.cli",
                "__jkspec.components.format"
              ],
              "validates": [
                {
                  "condition": "All deliverables are done",
                  "query": "[.specs.__jkspec.components.worker.view_inspection.deliverables | .. | .__meta? | select(. != null) | select(.done == false)] | length == 0"
                }
              ]
            },
            "problem": {
              "context": "Specs live as JSON which is hard for users to skim right after creation.",
              "pain_points": [
                "Users cannot easily review spec details without running jq queries",
                "Fresh specs may contain mistakes that go unnoticed without a readable view",
                "There is no automated habit enforcing view generation"
              ],
              "goal": "Provide an immediate, human-readable Markdown snapshot for each spec change.",
              "__meta": {
                "description": "Problem",
                "goal": "Rationale clearly documented and reviewed",
                "done": true,
                "implements": [],
                "references": [],
                "validates": []
              }
            },
            "deliverables": {
              "cli_tool": {
                "path": ".jkspec/cli/make_md_view.sh",
                "description": "Shell script that accepts a spec-id, JSON file path, and Markdown output path, then renders a deterministic Markdown view using jq.",
                "requirements": [
                  "Support any spec JSON structure that follows jkspec conventions",
                  "Gracefully handle missing optional sections by skipping them",
                  "Create parent directories for the output path automatically",
                  "Exit with non-zero status on invalid input"
                ],
                "__meta": {
                  "description": "Cli tool",
                  "goal": "Deliverable completed and verified",
                  "done": true,
                  "implements": [
                    "__jkspec.components.worker.view_inspection.deliverables"
                  ],
                  "references": [
                    "__jkspec.components.cli"
                  ],
                  "validates": []
                }
              },
              "worker_guideline": {
                "description": "Operational rule instructing workers to render Markdown views immediately after writing or updating a spec.",
                "output_location": ".tmp/<spec-id>.md",
                "rationale": "Keeps review loop tight and gives users a document they can open without tooling",
                "__meta": {
                  "description": "Worker guideline",
                  "goal": "Guideline documented and followed",
                  "done": true,
                  "implements": [
                    "__jkspec.components.worker.view_inspection.deliverables"
                  ],
                  "references": [
                    "__jkspec.components.worker.guidelines_structured"
                  ],
                  "validates": []
                }
              },
              "__meta": {
                "description": "Deliverables",
                "goal": "All child components marked as active",
                "done": true,
                "implements": [],
                "references": [
                  "__jkspec.components.cli"
                ],
                "validates": [
                  {
                    "condition": "All deliverables are done",
                    "query": "[.specs.__jkspec.components.worker.view_inspection.deliverables | to_entries[] | select(.key != \"__meta\") | select(.value.__meta.done == false)] | length == 0"
                  }
                ]
              }
            },
            "requirements": [
              {
                "id": "req-cli-view",
                "title": "CLI Markdown renderer",
                "priority": "critical",
                "description": "Implement make_md_view.sh to convert spec JSON into a Markdown document with sections for meta, problem, requirements, implementation, testing, tasks, and notes.",
                "__meta": {
                  "description": "Requirements specification",
                  "goal": "Requirement defined and satisfied",
                  "done": true,
                  "implements": [],
                  "references": [
                    "__jkspec.components.cli"
                  ],
                  "validates": []
                }
              },
              {
                "id": "req-tmp-folder",
                "title": "Temporary inspection workspace",
                "priority": "high",
                "description": "Ensure a top-level .tmp directory exists and always house rendered Markdown files there using the <spec-id>.md naming pattern.",
                "__meta": {
                  "description": "Requirements specification",
                  "goal": "Requirement defined and satisfied",
                  "done": true,
                  "implements": [],
                  "references": [
                    "__jkspec.components.format"
                  ],
                  "validates": []
                }
              },
              {
                "id": "req-workflow",
                "title": "Post-spec workflow",
                "priority": "high",
                "description": "Immediately after adding or editing a spec, export the spec JSON to a temp file and run the CLI to generate the Markdown view, then surface the output path in responses.",
                "__meta": {
                  "description": "Requirements specification",
                  "goal": "Requirement defined and satisfied",
                  "done": true,
                  "implements": [],
                  "references": [
                    "__jkspec.components.worker.documentation_bindings"
                  ],
                  "validates": []
                }
              }
            ],
            "workflow": {
              "steps": [
                "Finish jq edits to the target spec",
                "Validate the JSON file",
                "Create .tmp if it does not exist",
                "Export the spec JSON with jq to a temporary file",
                "Run .jkspec/cli/make_md_view.sh <spec-id> <json-path> .tmp/<spec-id>.md",
                "Reference the generated Markdown path in the user-facing summary"
              ],
              "automation_notes": "Future automation can watch .tmp for stale files and regenerate automatically",
              "__meta": {
                "description": "Workflow",
                "goal": "Rationale clearly documented and reviewed",
                "done": true,
                "implements": [],
                "references": [
                  "__jkspec.components.cli",
                  "__jkspec.components.worker.documentation_bindings"
                ],
                "validates": []
              }
            },
            "tasks": [
              {
                "__meta": {
                  "description": "Author make_md_view.sh with jq-based Markdown rendering",
                  "goal": "Task completed and verified",
                  "done": true,
                  "implements": [],
                  "references": [
                    "__jkspec.components.cli"
                  ],
                  "validates": []
                }
              },
              {
                "__meta": {
                  "description": "Append rule requiring Markdown view generation for each new/updated spec",
                  "goal": "Rule implemented and enforced",
                  "done": true,
                  "implements": [],
                  "references": [
                    "__jkspec.components.worker.guidelines_structured"
                  ],
                  "validates": []
                }
              },
              {
                "__meta": {
                  "description": "Generate a Markdown file for the latest spec to show the workflow",
                  "goal": "Task completed and verified",
                  "done": true,
                  "implements": [],
                  "references": [
                    "__jkspec.components.worker.documentation_bindings"
                  ],
                  "validates": []
                }
              }
            ],
            "notes": [
              "Store renderer outputs outside git-tracked areas to avoid noise (hence .tmp)",
              "Leverage jq exclusively so the script remains dependency-light"
            ]
          },
          "tasks": [
            {
              "__meta": {
                "description": "Use make_md_view.sh to generate .tmp/<spec-id>.md after spec updates",
                "goal": "Task completed and verified",
                "done": true,
                "implements": [],
                "references": [
                  "__jkspec.components.cli"
                ],
                "validates": []
              }
            }
          ],
          "status_management": {
            "__meta": {
              "done": true,
              "description": "Rules for managing spec done status transitions and ensuring spec completeness",
              "goal": "Status management rules documented and enforced",
              "implements": [],
              "references": [
                "__jkspec.components.traceability",
                "__jkspec.components.format"
              ],
              "validates": [
                {
                  "condition": "All examples have __meta",
                  "query": "[.specs.__jkspec.components.worker.status_management.examples | to_entries[] | select(.key != \"__meta\") | select(.value.__meta == null)] | length == 0"
                }
              ]
            },
            "completion_rule": "A spec can only be marked done: true when ALL its child components are also done: true",
            "upward_propagation": "When leaf tasks are completed, check parent specs to see if they can now be marked done: true",
            "required_fields": {
              "done": "boolean - false (not done) or true (goal accomplished)",
              "description": "string - what this spec describes",
              "goal": "string - what accomplishment means for this spec"
            },
            "optional_fields": {
              "type": "string - spec type (api, model, component, etc.)",
              "tags": "array - searchable tags for filtering"
            },
            "deprecation_prohibition": {
              "rule": "NEVER use deprecated field in __meta",
              "rationale": "Deprecation is a content-level concern, not metadata. Specs document reality - if something is deprecated, document it in the spec content, not meta",
              "correct_usage": "Add deprecated: true to individual features/functions/methods within spec content"
            },
            "examples": {
              "incomplete_task": {
                "__meta": {
                  "done": true,
                  "description": "Implement user authentication",
                  "goal": "Users can securely log in and maintain sessions",
                  "implements": [],
                  "references": [
                    "__jkspec.components.traceability"
                  ],
                  "validates": []
                }
              },
              "complete_task": {
                "__meta": {
                  "done": true,
                  "description": "Implement user authentication",
                  "goal": "Users can securely log in and maintain sessions",
                  "implements": [],
                  "references": [
                    "__jkspec.components.traceability"
                  ],
                  "validates": []
                }
              },
              "documenting_deprecated_features": {
                "__meta": {
                  "done": true,
                  "description": "Authentication API endpoints",
                  "implements": [],
                  "references": [],
                  "validates": []
                },
                "endpoints": {
                  "/login-session": {
                    "deprecated": true,
                    "replacement": "/login-jwt",
                    "removal_date": "2025-12-31"
                  },
                  "/login-jwt": {
                    "current": true
                  }
                }
              }
            }
          },
          "spec_definition": {
            "__meta": {
              "description": "Defines what constitutes a spec in jkspec",
              "goal": "Definition clearly documented and understood by all agents",
              "done": true,
              "implements": [],
              "references": [
                "__jkspec.components.format",
                "__jkspec.components.traceability"
              ],
              "validates": []
            },
            "core_principle": "Any object with a __meta object is a spec",
            "required_fields": {
              "status": "Implementation status (draft/active/deprecated)",
              "description": "What this spec describes",
              "goal": "Completion criteria - when to mark this spec as active"
            },
            "optional_fields": {
              "type": "Spec type for categorization (api, component, feature, etc.)",
              "tags": "Searchable tags",
              "location": "File path where implemented",
              "dependencies": "List of dependencies"
            },
            "recognition": "Agents identify specs by presence of __meta, regardless of field name or location in tree"
          },
          "guidelines_structured": {
            "description": "Operational guidelines organized by priority weight - higher weight = more critical",
            "critical": {
              "weight": 10,
              "description": "Absolutely mandatory rules - violation causes data corruption or system failure",
              "rules": [
                "MANDATORY: Before executing ANY user request, compare the request against bootstrap output. If the request relates to a field showing null, summary, or truncated data in bootstrap, the worker MUST fetch full detailed specs using targeted jq queries. Bootstrap summaries are intentional signals that complete definitions exist in source.json and should be loaded on-demand.",
                "Use jq for all spec reading and modifications - NEVER read or write directly to source.json or project.json files",
                "After ANY modification to source.json or project.json, IMMEDIATELY validate by running: bash .jkspec/tests/schema-validation/run_tests.sh. If validation fails, fix the issue before proceeding.",
                "NEVER use dangerous jq patterns that pipe to selectors (e.g., .path = value | .path) - see worker.jq_operations.safety for safe patterns",
                "Dual-file architecture: Check for .jkspec-project/project.json for user project specs, use .jkspec/source.json for framework specs",
                "File selection: Specs with __ prefix go to source.json (framework), specs without __ prefix go to project.json (user project)",
                "NEVER use deprecated field in __meta - deprecation belongs in spec content, not metadata",
                "Dependency tracking: Before marking any spec as done, MUST verify __meta.implements and __meta.references fields are current. Every spec should declare what it depends on (references) and what depends on it (implements) for bidirectional traceability."
              ]
            },
            "high": {
              "weight": 8,
              "description": "Very important rules - violation causes incorrect behavior or incomplete implementation",
              "rules": [
                "Spec completeness rule: Every spec and nested component MUST have a __meta object when first created, with done explicitly set to false or true",
                "Completion transition rule: A spec can only be marked as done: true when ALL its child components (nested objects, array items with __meta) are also marked as done: true",
                "Upward propagation: When implementing leaf tasks, always check if completing them allows parent specs to transition from done: false to done: true",
                "Default spec queries MUST target .jkspec-project/project.json unless the user explicitly requests framework specs",
                "Always validate input - check spec-id naming conventions and required fields before operations",
                "Cascade invalidation: When marking a spec as done=true, run enforce_cascade_invalidation.py to check if any specs that implement this one should be marked done=false. This ensures dependent specs stay synchronized with their references."
              ]
            },
            "medium": {
              "weight": 5,
              "description": "Important operational rules - enhance quality and user experience",
              "rules": [
                "After creating or updating any spec, export it to Markdown using .jkspec/cli/make_md_view.sh into .tmp/<spec-id>.md and share the inspection path with the user",
                "Task prioritization: When implementing, sort discovered drafts by JSON path length (longest first) to prioritize leaf-node tasks over parent specs",
                "Auto-create project.json: If .jkspec-project/project.json does not exist, create it with minimal template on first user spec operation",
                "New spec creation: Always add specs to .jkspec-project/project.json and never ask users to choose a scope unless they explicitly request a __ prefixed internal spec",
                "Handle errors gracefully with explanations",
                "Be concise and provide clear, actionable output",
                "Show results after operations",
                "Multi-layer bootstrap: Always run layer 1 (core) on init. Conditionally run layer 2 (project) when user request involves project specs (non-__ prefixed)",
                "Progressive depth loading: Start with bootstrap summaries, then query specific sections with jq when user request requires details"
              ]
            },
            "low": {
              "weight": 3,
              "description": "Style and convention preferences - improve consistency but not critical",
              "rules": [
                "Follow kebab-case convention for spec IDs",
                "Do not mention meta-specs or __jkspec components unless the user prompts for them",
                "Prevent spec drift: Never leave specs in an ambiguous state - every layer must have clear done status that reflects its actual implementation state",
                "Be autonomous within spec scope",
                "Ensure thorough implementation according to requirements"
              ]
            },
            "definitions": {
              "weight": 1,
              "description": "Informational rules - define concepts rather than mandate behavior",
              "rules": [
                "Spec definition: Any object with __meta is a spec - no specific field name required, can exist anywhere in the tree",
                "Task flexibility: Any object with __meta.done=false is a task - no specific field name required (can be in arrays like implementation_steps, requirements, test_cases, or anywhere)",
                "Spec completeness rule: Every spec and nested component MUST have a __meta object with REQUIRED fields: done (boolean), description (string), and goal (string). type is optional but recommended"
              ]
            },
            "__meta": {
              "description": "Structured guidelines with priority weights for worker behavior",
              "goal": "Organize guidelines by criticality to help worker prioritize conflicting rules",
              "done": true,
              "implements": [],
              "references": [
                "__jkspec.components.format",
                "__jkspec.components.dual-file-architecture",
                "__jkspec.components.traceability",
                "__jkspec.components.impact-tracking"
              ],
              "validates": [
                {
                  "condition": "All priority levels have weight and rules",
                  "query": "[.specs.__jkspec.components.worker.guidelines_structured | to_entries[] | select(.key != \"__meta\" and .key != \"description\") | select(.value.weight == null or .value.rules == null)] | length == 0"
                }
              ]
            }
          }
        },
        "traceability": {
          "__meta": {
            "type": "meta-guideline",
            "description": "Guideline for creating traceable specs with implementation status tracking using task arrays",
            "tags": [
              "meta",
              "guideline",
              "traceability"
            ],
            "purpose": "Define a standardized pattern for tracking implementation tasks within specs to ensure clear traceability between specification and actual code",
            "goal": "All child components marked as active",
            "done": true,
            "implements": [
              "specs.__jkspec.components.worker",
              "specs.__jkspec.components.worker.view_inspection",
              "specs.__jkspec.components.readme-documentation",
              "specs.__jkspec.components.dual-file-architecture",
              "specs.__jkspec.components.schema-validation",
              "specs.__jkspec.components.traceability.example_spec.example-api"
            ],
            "references": [
              "__jkspec.components.format"
            ],
            "validates": [
              {
                "condition": "All specs with tasks arrays should have task items with __meta.done field",
                "query": "[.. | objects | select(has(\"tasks\") and (.tasks | type == \"array\")) | .tasks[] | select(has(\"__meta\")) | .__meta | select(has(\"done\") | not)] | length == 0"
              }
            ]
          },
          "concept": "When creating code-related specs, include a tasks array where each element is a task object containing name, description, and done status",
          "pattern": {
            "tasks": {
              "description": "Array of task objects",
              "task_structure": {
                "__meta": {
                  "description": "string - Detailed description of what needs to be done",
                  "goal": "Structure defined and documented",
                  "done": true,
                  "implements": [],
                  "references": [
                    "__jkspec.components.format"
                  ],
                  "validates": []
                }
              },
              "__meta": {
                "description": "Tasks",
                "goal": "All child components marked as active",
                "done": true,
                "implements": [],
                "references": [
                  "__jkspec.components.format"
                ],
                "validates": [
                  {
                    "condition": "Tasks array should contain objects with __meta",
                    "query": "[.. | objects | select(has(\"tasks\") and (.tasks | type == \"array\")) | .tasks[] | select(has(\"__meta\") | not)] | length == 0"
                  }
                ]
              }
            },
            "__meta": {
              "description": "Pattern",
              "goal": "All child components marked as active",
              "done": true,
              "implements": [],
              "references": [
                "__jkspec.components.format"
              ],
              "validates": []
            }
          },
          "rationale": "Provides granular tracking of implementation progress with self-documenting task objects, enables clear verification of spec completion, maintains natural ordering, and keeps traceability between requirements and code",
          "when_to_use": "Propose this pattern when user creates specs that involve code implementation (files, components, APIs, features, etc.)",
          "example_spec": {
            "example-api": {
              "__meta": {
                "type": "api",
                "description": "Example REST API endpoint",
                "goal": "All child components marked as active",
                "done": true,
                "implements": [
                  "__jkspec.components.traceability.pattern.tasks"
                ],
                "references": [
                  "__jkspec.components.traceability.pattern"
                ],
                "validates": []
              },
              "tasks": [
                {
                  "__meta": {
                    "description": "Create endpoint handler function",
                    "goal": "Task completed and verified",
                    "done": true,
                    "implements": [],
                    "references": [
                      "__jkspec.components.traceability.pattern.tasks.task_structure"
                    ],
                    "validates": []
                  }
                },
                {
                  "__meta": {
                    "description": "Add input validation for request parameters",
                    "goal": "Task completed and verified",
                    "done": true,
                    "implements": [],
                    "references": [
                      "__jkspec.components.traceability.pattern.tasks.task_structure"
                    ],
                    "validates": []
                  }
                },
                {
                  "__meta": {
                    "description": "Write unit tests for the endpoint",
                    "goal": "Task completed and verified",
                    "done": true,
                    "implements": [],
                    "references": [
                      "__jkspec.components.traceability.pattern.tasks.task_structure"
                    ],
                    "validates": []
                  }
                }
              ]
            },
            "__meta": {
              "description": "Example spec",
              "goal": "All child components marked as active",
              "done": true,
              "implements": [],
              "references": [
                "__jkspec.components.traceability.pattern"
              ],
              "validates": []
            }
          },
          "best_practices": [
            "Order tasks in logical sequence (implementation order)",
            "Use concise but clear names for tasks",
            "Provide detailed descriptions explaining what each task involves",
            "Set all task.done to false initially when spec is created",
            "Update task.done to true as each component is implemented",
            "Consider updating overall spec status to active when all tasks are done"
          ],
          "advantages": [
            "Natural ordering - tasks appear in implementation sequence",
            "Easy to iterate - can use array methods and jq array operations",
            "Simple indexing - access by position (tasks[0], tasks[1], etc.)",
            "Clean structure - no need for numbered keys",
            "Easy to add/remove tasks without renumbering"
          ],
          "agent_behavior": "When user requests to create a spec related to code, suggest including the tasks array pattern and offer to add task objects based on the spec requirements"
        },
        "readme-documentation": {
          "__meta": {
            "type": "documentation",
            "description": "README.md documentation for jkspec project with vision, advantages, disadvantages, and buy-me-a-coffee support button",
            "tags": [
              "documentation",
              "meta",
              "readme"
            ],
            "location": "README.md",
            "purpose": "Provide clear, honest documentation about jkspec as a prototype with potential for agent-driven development",
            "goal": "All child components marked as active",
            "done": true,
            "implements": [],
            "references": [
              "__jkspec.components.format",
              "__jkspec.components.cli"
            ],
            "validates": [
              {
                "condition": "README.md exists and is non-empty",
                "query": "test -f README.md && test -s README.md"
              }
            ]
          },
          "sections": {
            "header": {
              "title": "jkspec",
              "tagline": "JSON-based specification format for rapid AI agent context retrieval"
            },
            "what_is_jkspec": {
              "description": "Explain what jkspec is and its core purpose",
              "content_draft": "jkspec is a single-file, JSON-based specification format designed to eliminate the context-gathering overhead AI agents face when working with codebases. Instead of agents spending time exploring directories, reading multiple files, and piecing together project structure, jkspec provides a centralized `.jkspec/source.json` file that agents can query instantly using `jq`.\n\nThink of it as a \"map\" for AI agents - a structured, queryable source of truth about your project's architecture, components, conventions, and implementation status."
            },
            "vision": {
              "description": "The vision and philosophy behind jkspec",
              "content_draft": "The vision of jkspec emerged from observing a consistent pattern: AI agents waste significant time and tokens exploring codebases before they can start actual work. Every conversation begins with \"let me look at your project structure\" followed by multiple file reads and questions.\n\njkspec flips this paradigm. What if agents could instantly access:\n- Project architecture and conventions\n- What exists and what doesn't\n- Implementation status of features\n- Dependencies and relationships\n- Historical decisions and rationale\n\nAll queryable in milliseconds with simple `jq` commands.\n\nThe broader vision is **spec-driven development with AI agents** - where specifications aren't just documentation, but active, queryable contracts that guide agent behavior and reduce ambiguity."
            },
            "prototype_notice": {
              "description": "Transparent notice that this is a prototype",
              "tone": "honest and encouraging",
              "content_draft": " **This is a prototype.** jkspec is an experiment in improving AI agent workflows. It's rough around the edges, the conventions are still evolving, and there are likely better ways to solve some of these problems.\n\nThat said, I've found it genuinely useful in my own agent-assisted development, and I believe the core idea has potential. If you're interested in exploring new ways to work with AI coding assistants, give it a try. Feedback, ideas, and constructive criticism are welcome.",
              "__meta": {
                "description": "Prototype notice",
                "goal": "Section written, reviewed, and published",
                "done": true,
                "implements": [],
                "references": [],
                "validates": [
                  {
                    "condition": "README.md contains prototype notice",
                    "query": "grep -q \"This is a prototype\" README.md"
                  }
                ]
              }
            },
            "advantages": {
              "description": "Key advantages of using jkspec",
              "items": [
                {
                  "title": "Instant Context",
                  "description": "Agents get full project context in a single jq query - no exploration needed"
                },
                {
                  "title": "Single Source of Truth",
                  "description": "One file contains architecture, conventions, specs, and status - no scattered documentation"
                },
                {
                  "title": "Queryable Structure",
                  "description": "Use jq to filter by type, status, tags - agents can find exactly what they need"
                },
                {
                  "title": "Implementation Tracking",
                  "description": "Track what's draft vs active vs deprecated - clear visibility into project state"
                },
                {
                  "title": "Hierarchical Specs",
                  "description": "Nest specs arbitrarily deep to match your architecture - from high-level features down to specific validations"
                },
                {
                  "title": "Version Control Friendly",
                  "description": "JSON file diffs clearly show spec changes - easy to review and track evolution"
                },
                {
                  "title": "No External Dependencies",
                  "description": "Just JSON and jq - no special tools or frameworks required"
                },
                {
                  "title": "Agent-Optimized",
                  "description": "Designed specifically for AI agent consumption, not just human documentation"
                }
              ],
              "__meta": {
                "description": "Advantages",
                "goal": "Section written, reviewed, and published",
                "done": true,
                "implements": [],
                "references": [],
                "validates": [
                  {
                    "condition": "README.md contains advantages section",
                    "query": "grep -q -i \"advantages\\|benefits\" README.md"
                  }
                ]
              }
            },
            "disadvantages": {
              "description": "Honest assessment of current limitations and tradeoffs",
              "items": [
                {
                  "title": "Manual Sync Required",
                  "description": "Specs don't automatically update when code changes - requires discipline to keep in sync"
                },
                {
                  "title": "Learning Curve",
                  "description": "Requires learning jq syntax and understanding the jkspec structure conventions"
                },
                {
                  "title": "JSON Verbosity",
                  "description": "JSON can be verbose - large projects might have unwieldy source.json files"
                },
                {
                  "title": "Not Human-Optimized",
                  "description": "Reading raw JSON isn't as pleasant as markdown docs for humans (though agents don't mind)"
                },
                {
                  "title": "Prototype Limitations",
                  "description": "Conventions still evolving, tooling is minimal, edge cases not fully explored"
                },
                {
                  "title": "Single File Bottleneck",
                  "description": "All specs in one file can cause merge conflicts in team environments"
                },
                {
                  "title": "No Schema Validation Yet",
                  "description": "While a schema exists, enforcement and validation tooling is minimal"
                }
              ],
              "__meta": {
                "description": "Disadvantages",
                "goal": "Section written, reviewed, and published",
                "done": true,
                "implements": [],
                "references": [],
                "validates": [
                  {
                    "condition": "README.md contains disadvantages section",
                    "query": "grep -q -i \"disadvantages\\|limitations\\|tradeoffs\" README.md"
                  }
                ]
              }
            },
            "quick_start": {
              "description": "Basic quick start instructions",
              "content_draft": "1. Clone jkspec into your project (without git history):\n   ```bash\n   npx degit jkf16m/jkspec .jkspec\n   ```\n\n2. The `.jkspec/source.json` file is your starting template - customize it:\n   - Update the `project` section with your project details\n   - **NEVER remove `__jkspec`** - it defines the jkspec framework itself\n   - Modifying `__jkspec` means modifying the framework (jkspec is self-modifiable by design)\n   - Add your own specs to the `specs` object using kebab-case keys\n\n3. Query with jq: `jq '.specs' .jkspec/source.json`\n\nFor AI agents: Point your agent to `.jkspec/source.json` and give it access to `jq`."
            },
            "core_concepts": {
              "description": "Brief explanation of core jkspec concepts",
              "concepts": [
                {
                  "name": "Specs",
                  "description": "Each spec has a `__meta` object (type, description, status, tags) plus any custom fields"
                },
                {
                  "name": "Status Lifecycle",
                  "description": "draft  active  deprecated"
                },
                {
                  "name": "Hierarchical Structure",
                  "description": "Specs can nest using keys like children, components, endpoints, tests, etc."
                },
                {
                  "name": "Internal Specs",
                  "description": "Specs prefixed with `__` are internal/meta specs that define the framework itself (like `__jkspec`). These specs should never be deleted. Modifying them means modifying the jkspec framework behavior - the framework is intentionally self-modifiable"
                },
                {
                  "name": "jq Queries",
                  "description": "Direct JSON manipulation using jq for all read/write operations"
                }
              ],
              "__meta": {
                "description": "Core concepts",
                "goal": "Section written, reviewed, and published",
                "done": true,
                "implements": [],
                "references": [
                  "__jkspec.components.format"
                ],
                "validates": [
                  {
                    "condition": "README.md contains core concepts section",
                    "query": "grep -q -i \"core concepts\\|key concepts\" README.md"
                  }
                ]
              }
            },
            "examples": {
              "description": "Practical jq examples",
              "queries": [
                {
                  "description": "List all specs",
                  "command": "jq .specs | keys .jkspec/source.json"
                },
                {
                  "description": "Get a specific spec",
                  "command": "jq .specs[\"spec-name\"] .jkspec/source.json"
                },
                {
                  "description": "Find all draft specs",
                  "command": "jq .specs | to_entries[] | select(.value.__meta.status == \"draft\") .jkspec/source.json"
                },
                {
                  "description": "Filter by type",
                  "command": "jq .specs | to_entries[] | select(.value.__meta.type == \"api\") .jkspec/source.json"
                }
              ],
              "__meta": {
                "description": "Example specifications",
                "goal": "Example provided and working",
                "done": true,
                "implements": [],
                "references": [],
                "validates": [
                  {
                    "condition": "README.md contains jq examples",
                    "query": "grep -q \"jq .specs\" README.md"
                  }
                ]
              }
            },
            "use_cases": {
              "description": "When jkspec might be useful",
              "scenarios": [
                "Working with AI coding agents frequently",
                "Want to reduce agent context-gathering overhead",
                "Need structured, queryable project documentation",
                "Exploring spec-driven development approaches",
                "Building agent-first development workflows"
              ],
              "__meta": {
                "description": "Use cases",
                "goal": "Section written, reviewed, and published",
                "done": true,
                "implements": [],
                "references": [],
                "validates": [
                  {
                    "condition": "README.md contains use cases section",
                    "query": "grep -q -i \"use cases\\|when.*useful\" README.md"
                  }
                ]
              }
            },
            "support": {
              "description": "Buy me a coffee section at the end",
              "content_draft": "If you find jkspec useful or interesting, consider buying me a coffee! This is a personal experiment and any support helps me continue exploring ideas like this.\n\n[![Buy Me A Coffee](https://www.buymeacoffee.com/assets/img/custom_images/orange_img.png)](https://buymeacoffee.com/jdfm24)"
            },
            "__meta": {
              "description": "Documentation sections",
              "goal": "All child components marked as active",
              "done": true,
              "implements": [],
              "references": [
                "__jkspec.components.format"
              ],
              "validates": [
                {
                  "condition": "All section child components are done",
                  "query": "[.specs.__jkspec.components.\"readme-documentation\".sections | .. | objects | select(has(\"__meta\")) | .__meta.done] | all"
                }
              ]
            }
          },
          "tasks": [
            {
              "__meta": {
                "description": "Create project title and compelling tagline",
                "goal": "Task completed and verified",
                "done": true,
                "implements": [],
                "references": [],
                "validates": []
              }
            },
            {
              "__meta": {
                "description": "Clear explanation of what jkspec is and core purpose",
                "goal": "Task completed and verified",
                "done": true,
                "implements": [],
                "references": [],
                "validates": []
              }
            },
            {
              "__meta": {
                "description": "Explain the vision and philosophy behind jkspec",
                "goal": "Task completed and verified",
                "done": true,
                "implements": [],
                "references": [],
                "validates": []
              }
            },
            {
              "__meta": {
                "description": "Honest, encouraging notice about prototype status",
                "goal": "Task completed and verified",
                "done": true,
                "implements": [],
                "references": [],
                "validates": []
              }
            },
            {
              "__meta": {
                "description": "List key advantages with clear descriptions",
                "goal": "Task completed and verified",
                "done": true,
                "implements": [],
                "references": [],
                "validates": []
              }
            },
            {
              "__meta": {
                "description": "Honest assessment of limitations and tradeoffs",
                "goal": "Task completed and verified",
                "done": true,
                "implements": [],
                "references": [],
                "validates": []
              }
            },
            {
              "__meta": {
                "description": "Simple getting started instructions",
                "goal": "Task completed and verified",
                "done": true,
                "implements": [],
                "references": [],
                "validates": []
              }
            },
            {
              "__meta": {
                "description": "Brief explanation of key jkspec concepts",
                "goal": "Task completed and verified",
                "done": true,
                "implements": [],
                "references": [],
                "validates": []
              }
            },
            {
              "__meta": {
                "description": "Practical jq query examples",
                "goal": "Example provided and working",
                "done": true,
                "implements": [],
                "references": [],
                "validates": []
              }
            },
            {
              "__meta": {
                "description": "When jkspec might be useful",
                "goal": "Task completed and verified",
                "done": true,
                "implements": [],
                "references": [],
                "validates": []
              }
            },
            {
              "__meta": {
                "description": "Add support button with link at the end",
                "goal": "Task completed and verified",
                "done": true,
                "implements": [],
                "references": [],
                "validates": []
              }
            },
            {
              "__meta": {
                "description": "Final review for tone, clarity, and completeness",
                "goal": "Task completed and verified",
                "done": true,
                "implements": [],
                "references": [],
                "validates": []
              }
            }
          ],
          "style_guidelines": {
            "tone": "Honest, pragmatic, encouraging",
            "voice": "First-person when discussing prototype status and personal experience",
            "technical_level": "Accessible to developers familiar with JSON and basic command-line tools",
            "approach": "Lead with value proposition, be transparent about limitations, focus on practical utility",
            "__meta": {
              "description": "Style guidelines",
              "goal": "Guideline documented and followed",
              "done": true,
              "implements": [],
              "references": [],
              "validates": []
            }
          },
          "references": {
            "output_file": "README.md",
            "source_meta_specs": [
              "__jkspec.components.worker",
              "__jkspec.components.format",
              "__jkspec.components.depth-system",
              "__jkspec.components.traceability",
              "__jkspec.components.dual-file-architecture",
              "__jkspec.components.schema-validation"
            ],
            "update_policy": "If any referenced meta-spec status is draft, keep this spec in draft and regenerate README.md from the template before marking it active again.",
            "__meta": {
              "description": "References",
              "goal": "Values defined and documented",
              "done": true,
              "implements": [],
              "references": [
                "__jkspec.components.worker",
                "__jkspec.components.format",
                "__jkspec.components.depth-system",
                "__jkspec.components.traceability",
                "__jkspec.components.dual-file-architecture",
                "__jkspec.components.schema-validation"
              ],
              "validates": [
                {
                  "condition": "All referenced specs exist in source.json",
                  "query": "[.specs.__jkspec.components.worker, .specs.__jkspec.components.format, .specs.__jkspec.components.\"depth-system\", .specs.__jkspec.components.traceability, .specs.__jkspec.components.\"dual-file-architecture\", .specs.__jkspec.components.\"schema-validation\"] | all"
                }
              ]
            }
          },
          "template_structure": {
            "description": "Canonical README scaffold that is regenerated whenever referenced meta-specs change",
            "section_order": [
              "header",
              "what_is_jkspec",
              "vision",
              "prototype_notice",
              "advantages",
              "disadvantages",
              "quick_start",
              "core_concepts",
              "examples",
              "use_cases",
              "support"
            ],
            "regeneration_steps": [
              "Check statuses of all source_meta_specs using jq",
              "Extract updated content from each referenced meta-spec",
              "Rewrite README sections according to this template order",
              "Review tone/style guidelines and update Buy Me a Coffee section",
              "Set readme-documentation.__meta.status back to active only after README.md has been updated"
            ],
            "validation_signal": "jkspec-validate surfaces a reminder whenever readme-documentation.__meta.status is draft, indicating README.md must be regenerated.",
            "__meta": {
              "description": "Template structure",
              "goal": "Template created and usable",
              "done": true,
              "implements": [],
              "references": [
                "__jkspec.components.cli"
              ],
              "validates": [
                {
                  "condition": "make_md_view.sh or spec-to-md.py exists",
                  "query": "test -f .jkspec/cli/make_md_view.sh || test -f .jkspec/cli/spec-to-md.py"
                }
              ]
            }
          }
        },
        "dual-file-architecture": {
          "__meta": {
            "type": "architecture",
            "description": "Dual-file architecture separating jkspec framework from project specifications",
            "tags": [
              "architecture",
              "meta",
              "separation-of-concerns"
            ],
            "purpose": "Enable clean separation between jkspec framework tooling and user project specs, allowing framework updates without affecting project data",
            "complexity": "high",
            "subagent_required": true,
            "goal": "All child components marked as active",
            "done": true,
            "references": [
              "specs.__jkspec.components.format",
              "specs.__jkspec.components.schema-validation"
            ],
            "implements": [
              "specs.__jkspec.components.worker.guidelines_structured.critical.rules[4]",
              "specs.__jkspec.components.worker.guidelines_structured.critical.rules[5]",
              "specs.__jkspec.components.cli.utilities.bootstrap"
            ]
          },
          "rationale": {
            "problem": "Currently .jkspec/source.json contains both jkspec framework specs (__jkspec) and project specs. This makes it difficult to update jkspec tooling without affecting user data.",
            "solution": "Split into two files: .jkspec/source.json (framework) and .jkspec-project/project.json (user specs). Users can update framework by cloning fresh .jkspec/ directory.",
            "benefits": [
              "Clear separation between framework and project data",
              "Users can update jkspec by deleting .jkspec/ and cloning fresh",
              "Project specs remain untouched during framework updates",
              "Transferable project.json can be shared across teams",
              "Framework and project can evolve independently"
            ],
            "__meta": {
              "description": "Rationale",
              "goal": "Rationale clearly documented and reviewed",
              "done": true,
              "references": [],
              "implements": [
                "specs.__jkspec.components.dual-file-architecture.architecture"
              ]
            }
          },
          "architecture": {
            "framework_location": {
              "path": ".jkspec/",
              "description": "Contains jkspec framework specifications and tooling",
              "files": {
                "source.json": {
                  "description": "Framework specifications including __jkspec meta specs",
                  "contains": [
                    "project metadata about jkspec itself",
                    "__jkspec spec with all framework components",
                    "worker configuration",
                    "Internal framework specs only"
                  ],
                  "modifiable": "Only when modifying the jkspec framework itself",
                  "__meta": {
                    "description": "Json",
                    "goal": "Structure defined and documented",
                    "done": true,
                    "references": [
                      "specs.__jkspec.components.format"
                    ],
                    "implements": [
                      "specs.__jkspec.components.worker.jq_operations"
                    ],
                    "validates": "[ -f .jkspec/source.json ] && jq empty .jkspec/source.json 2>&1"
                  }
                },
                "jkspec.schema.json": {
                  "description": "JSON Schema used by both source.json and project.json",
                  "shared": true,
                  "__meta": {
                    "description": "Schema file definition",
                    "goal": "Schema structure defined and documented",
                    "done": true,
                    "references": [
                      "specs.__jkspec.components.schema-validation"
                    ],
                    "implements": [
                      "specs.__jkspec.components.worker.guidelines_structured.critical.rules[2]"
                    ],
                    "validates": "[ -f .jkspec/jkspec.schema.json ] && echo \"Schema file exists\""
                  }
                },
                "__meta": {
                  "description": "Files",
                  "goal": "All child components marked as active",
                  "done": true,
                  "references": [],
                  "implements": []
                }
              },
              "__meta": {
                "description": "Framework location",
                "goal": "All child components marked as active",
                "done": true,
                "references": [
                  "specs.__jkspec.components.format"
                ],
                "implements": [
                  "specs.__jkspec.components.cli.utilities.bootstrap"
                ]
              }
            },
            "project_location": {
              "path": ".jkspec-project/",
              "description": "Contains user project specifications",
              "files": {
                "project.json": {
                  "description": "User project specifications",
                  "schema": "Uses .jkspec/jkspec.schema.json",
                  "contains": [
                    "project metadata for the user's actual project",
                    "User-defined specs (no __ prefix)",
                    "Project-specific conventions and decisions",
                    "All user spec data"
                  ],
                  "transferable": true,
                  "modifiable": "Users freely modify this for their project",
                  "__meta": {
                    "description": "Json",
                    "goal": "Structure defined and documented",
                    "done": true,
                    "references": [
                      "specs.__jkspec.components.format",
                      "specs.__jkspec.components.dual-file-architecture.project_json_template"
                    ],
                    "implements": [
                      "specs.__jkspec.components.worker.jq_operations"
                    ],
                    "validates": "[ -f .jkspec-project/project.json ] && jq empty .jkspec-project/project.json 2>&1 || echo \"project.json not required in jkspec repo\""
                  }
                },
                "__meta": {
                  "description": "Files",
                  "goal": "All child components marked as active",
                  "done": true,
                  "references": [],
                  "implements": []
                }
              },
              "note": "Not created in jkspec repo - only in user projects",
              "__meta": {
                "description": "Project location",
                "goal": "All child components marked as active",
                "done": true,
                "references": [
                  "specs.__jkspec.components.format"
                ],
                "implements": [
                  "specs.__jkspec.components.cli.utilities.bootstrap",
                  "specs.__jkspec.components.worker.guidelines_structured.medium.rules[2]"
                ]
              }
            },
            "__meta": {
              "description": "Architectural overview and structure",
              "goal": "All child components marked as active",
              "done": true,
              "references": [
                "specs.__jkspec.components.format"
              ],
              "implements": [
                "specs.__jkspec.components.dual-file-architecture.worker_integration.file_selection_logic"
              ]
            }
          },
          "schema_usage": {
            "description": "Both files use the same jkspec.schema.json for validation",
            "framework_file": ".jkspec/source.json validates against .jkspec/jkspec.schema.json",
            "project_file": ".jkspec-project/project.json validates against .jkspec/jkspec.schema.json",
            "shared_structure": {
              "project": "Both files have project object with different metadata",
              "specs": "Both files have specs object with different content",
              "worker": ".jkspec/source.json contains worker config, .jkspec-project/project.json does not need it",
              "__meta": {
                "description": "Shared structure",
                "goal": "Structure defined and documented",
                "done": true,
                "references": [
                  "specs.__jkspec.components.format"
                ],
                "implements": []
              }
            },
            "__meta": {
              "description": "Schema usage",
              "goal": "All child components marked as active",
              "done": true,
              "references": [
                "specs.__jkspec.components.schema-validation"
              ],
              "implements": [
                "specs.__jkspec.components.worker.guidelines_structured.critical.rules[2]"
              ]
            }
          },
          "agent_behavior": {
            "initialization": {
              "description": "How agents should initialize and discover spec files",
              "discovery_order": [
                "1. Check if .jkspec-project/ directory exists",
                "2. If not exists, create .jkspec-project/ directory",
                "3. Check if .jkspec-project/project.json exists",
                "4. If not exists, create project.json with minimal template",
                "5. Always read .jkspec/source.json for framework specs and worker config",
                "6. Always read .jkspec-project/project.json for user project specs"
              ],
              "__meta": {
                "description": "Initialization",
                "goal": "Bootstrap logic implemented and tested",
                "done": true,
                "references": [
                  "specs.__jkspec.components.dual-file-architecture.architecture.project_location"
                ],
                "implements": [
                  "specs.__jkspec.components.cli.utilities.bootstrap"
                ]
              }
            },
            "bootstrap_modification": {
              "description": "Worker bootstrap needs to check for project file existence",
              "location": "Update worker.bootstrap or add to worker guidelines",
              "new_checks": [
                "Check .jkspec-project/ existence before any operations",
                "Auto-create .jkspec-project/project.json if missing",
                "Inform user when creating new project file"
              ],
              "__meta": {
                "description": "Bootstrap modification",
                "goal": "Bootstrap logic implemented and tested",
                "done": true,
                "references": [
                  "specs.__jkspec.components.worker.guidelines_structured"
                ],
                "implements": [
                  "specs.__jkspec.components.cli.utilities.bootstrap"
                ]
              }
            },
            "query_strategy": {
              "framework_queries": "Use .jkspec/source.json for framework and worker info",
              "project_queries": "Use .jkspec-project/project.json for user project specs",
              "combined_view": "Agents may need to query both files for complete context",
              "__meta": {
                "description": "Query strategy",
                "goal": "Policy defined and documented",
                "done": true,
                "references": [
                  "specs.__jkspec.components.worker.jq_operations"
                ],
                "implements": [
                  "specs.__jkspec.components.worker.guidelines_structured.critical.rules[4]",
                  "specs.__jkspec.components.worker.guidelines_structured.critical.rules[5]"
                ]
              }
            },
            "__meta": {
              "description": "Agent behavior",
              "goal": "All child components marked as active",
              "done": true,
              "references": [
                "specs.__jkspec.components.worker.guidelines_structured"
              ],
              "implements": [
                "specs.__jkspec.components.cli.utilities.bootstrap"
              ]
            }
          },
          "migration": {
            "description": "How to migrate existing projects from single-file to dual-file",
            "from_current_structure": {
              "step_1": "Identify user specs (non-__ prefix) in current .jkspec/source.json",
              "step_2": "Create .jkspec-project/ directory",
              "step_3": "Create project.json with project metadata and user specs only",
              "step_4": "Remove user specs from .jkspec/source.json, keep only __jkspec and framework specs",
              "step_5": "Update .jkspec/source.json project metadata to describe jkspec framework itself",
              "step_6": "Test agent queries against both files",
              "__meta": {
                "description": "From current structure",
                "goal": "Structure defined and documented",
                "done": true,
                "references": [
                  "specs.__jkspec.components.dual-file-architecture.architecture",
                  "specs.__jkspec.components.dual-file-architecture.worker_integration.file_selection_logic"
                ],
                "implements": []
              }
            },
            "__meta": {
              "description": "Migration",
              "goal": "All child components marked as active",
              "done": true,
              "references": [
                "specs.__jkspec.components.dual-file-architecture.architecture"
              ],
              "implements": []
            }
          },
          "project_json_template": {
            "description": "Minimal template for new .jkspec-project/project.json",
            "template": {
              "project": {
                "name": "your-project-name",
                "description": "Your project description",
                "version": "0.1.0",
                "architecture": {
                  "style": "Define your architecture style",
                  "pattern": "Define your patterns"
                },
                "conventions": {
                  "spec_location": ".jkspec-project/project.json"
                },
                "decisions": [],
                "__meta": {
                  "description": "Project-level metadata and configuration",
                  "goal": "Configuration properly defined and documented",
                  "done": true,
                  "references": [
                    "specs.__jkspec.components.format"
                  ],
                  "implements": []
                }
              },
              "specs": {},
              "__meta": {
                "description": "Template",
                "goal": "All child components marked as active",
                "done": true,
                "references": [
                  "specs.__jkspec.components.format"
                ],
                "implements": []
              }
            },
            "__meta": {
              "description": "Project json template",
              "goal": "All child components marked as active",
              "done": true,
              "references": [
                "specs.__jkspec.components.format"
              ],
              "implements": [
                "specs.__jkspec.components.cli.utilities.bootstrap",
                "specs.__jkspec.components.worker.guidelines_structured.medium.rules[2]"
              ]
            }
          },
          "worker_integration": {
            "description": "How worker commands should integrate with dual-file architecture",
            "command_modifications": {
              "jkspec-extend": "Should add user specs to .jkspec-project/project.json, not source.json",
              "jkspec-update": "Should determine which file to update based on spec prefix (__ = source.json, else = project.json)",
              "jkspec-validate": "Should validate both files",
              "jkspec-analyze": "Should analyze both files and report on each",
              "jkspec-suggest-specs": "Should suggest specs for project.json",
              "jkspec-test-sync": "Should check implementations for specs in project.json",
              "jkspec-implement": "Should work with specs from project.json",
              "jkspec-explain": "Should explain specs from either file",
              "jkspec-verify": "Should verify implementations from project.json",
              "__meta": {
                "description": "Command modifications",
                "goal": "Integration implemented and tested",
                "done": true,
                "references": [
                  "specs.__jkspec.components.worker.commands_definitions"
                ],
                "implements": [
                  "specs.__jkspec.components.worker.commands_definitions.jkspec-extend",
                  "specs.__jkspec.components.worker.commands_definitions.jkspec-implement"
                ]
              }
            },
            "file_selection_logic": {
              "rule_1": "If spec-id starts with __, use .jkspec/source.json (framework)",
              "rule_2": "If spec-id does NOT start with __, use .jkspec-project/project.json (user project)",
              "rule_3": "Worker config always read from .jkspec/source.json",
              "rule_4": "Project specs always read from .jkspec-project/project.json",
              "__meta": {
                "description": "File selection logic",
                "goal": "Integration implemented and tested",
                "done": true,
                "references": [
                  "specs.__jkspec.components.dual-file-architecture.architecture"
                ],
                "implements": [
                  "specs.__jkspec.components.worker.guidelines_structured.critical.rules[5]",
                  "specs.__jkspec.components.worker.jq_operations"
                ],
                "validates": "jq -e \".specs.__jkspec.components.\\\"dual-file-architecture\\\".worker_integration.file_selection_logic | has(\\\"rule_1\\\") and has(\\\"rule_2\\\")\" .jkspec/source.json"
              }
            },
            "__meta": {
              "description": "Worker integration",
              "goal": "All child components marked as active",
              "done": true,
              "references": [
                "specs.__jkspec.components.worker.commands_definitions"
              ],
              "implements": [
                "specs.__jkspec.components.worker.commands_definitions.jkspec-extend",
                "specs.__jkspec.components.worker.commands_definitions.jkspec-implement",
                "specs.__jkspec.components.worker.commands_definitions.jkspec-deepen"
              ]
            }
          },
          "tasks": [
            {
              "__meta": {
                "description": "Add project file discovery to worker.guidelines so agents know to check for .jkspec-project/project.json",
                "goal": "Guideline documented and followed",
                "done": true,
                "references": [
                  "specs.__jkspec.components.worker.guidelines_structured"
                ],
                "implements": [
                  "specs.__jkspec.components.worker.guidelines_structured.critical.rules[4]"
                ]
              }
            },
            {
              "__meta": {
                "description": "Add or update spec documenting that validation uses ajv for both source.json and project.json",
                "goal": "Task completed and verified",
                "done": true,
                "references": [
                  "specs.__jkspec.components.schema-validation"
                ],
                "implements": [
                  "specs.__jkspec.components.worker.guidelines_structured.critical.rules[2]"
                ]
              }
            },
            {
              "__meta": {
                "description": "Create tests in .jkspec/tests/ to verify agent behavior with dual-file setup",
                "goal": "Task completed and verified",
                "done": true,
                "references": [
                  "specs.__jkspec.components.dual-file-architecture.test_scenarios"
                ],
                "implements": [
                  "specs.__jkspec.components.dual-file-architecture.test_scenarios"
                ]
              }
            },
            {
              "__meta": {
                "description": "Update command markdown files to document file selection logic (__ prefix = source.json, no prefix = project.json)",
                "goal": "Task completed and verified",
                "done": true,
                "references": [
                  "specs.__jkspec.components.dual-file-architecture.worker_integration.file_selection_logic"
                ],
                "implements": []
              }
            },
            {
              "__meta": {
                "description": "Document in README that users get project.json auto-created in their projects",
                "goal": "Task completed and verified",
                "done": true,
                "references": [
                  "specs.__jkspec.components.dual-file-architecture.architecture.project_location"
                ],
                "implements": []
              }
            }
          ],
          "implementation_note": "This is a meta-spec only. The .jkspec-project/ directory and project.json file are NOT created in the jkspec repository itself. They are auto-created by agents when users use jkspec in their own projects.",
          "test_scenarios": {
            "description": "Test scenarios to verify dual-file architecture behavior",
            "test_location": ".jkspec/tests/dual-file-architecture/",
            "scenarios": {
              "project_json_discovery": {
                "description": "Test that agents properly discover or create project.json",
                "setup": "Temporary directory with .jkspec/ but no .jkspec-project/",
                "expected": "Agent creates .jkspec-project/project.json with minimal template",
                "test_file": "test_project_discovery.js",
                "__meta": {
                  "description": "Project json discovery",
                  "goal": "Test scenario implemented and passing",
                  "done": true,
                  "references": [
                    "specs.__jkspec.components.dual-file-architecture.agent_behavior.initialization"
                  ],
                  "implements": [],
                  "validates": "[ -f .jkspec/tests/dual-file-architecture/test_project_discovery.sh ] && echo \"Test exists\""
                }
              },
              "file_selection_by_prefix": {
                "description": "Test that __ prefix specs route to source.json, others to project.json",
                "setup": "Both source.json and project.json exist",
                "operations": [
                  "Query __jkspec spec - should read from source.json",
                  "Query user-spec (no __) - should read from project.json",
                  "Add spec with __ prefix - should write to source.json",
                  "Add spec without __ prefix - should write to project.json"
                ],
                "test_file": "test_file_selection.js",
                "__meta": {
                  "description": "File selection by prefix",
                  "goal": "Test scenario implemented and passing",
                  "done": true,
                  "references": [
                    "specs.__jkspec.components.dual-file-architecture.worker_integration.file_selection_logic"
                  ],
                  "implements": [],
                  "validates": "[ -f .jkspec/tests/dual-file-architecture/test_file_selection.sh ] && echo \"Test exists\""
                }
              },
              "schema_validation_both_files": {
                "description": "Test that validation validates both files",
                "setup": "Both source.json and project.json with valid specs",
                "expected": "Both files pass ajv validation against jkspec.schema.json",
                "test_file": "test_schema_validation.js",
                "__meta": {
                  "description": "Schema validation both files",
                  "goal": "Test scenario implemented and passing",
                  "done": true,
                  "references": [
                    "specs.__jkspec.components.schema-validation",
                    "specs.__jkspec.components.dual-file-architecture.schema_usage"
                  ],
                  "implements": [],
                  "validates": "[ -f .jkspec/tests/dual-file-architecture/test_schema_validation.sh ] && echo \"Test exists\" || echo \"Test file not found\""
                }
              },
              "project_json_required": {
                "description": "Test that operations BLOCK until project.json exists (create it automatically if missing)",
                "setup": "Only .jkspec/source.json exists",
                "expected": ".jkspec-project/project.json is auto-created before accepting user specs",
                "test_file": "test_project_required.js",
                "__meta": {
                  "description": "Project json required",
                  "goal": "Test scenario implemented and passing",
                  "done": true,
                  "references": [
                    "specs.__jkspec.components.dual-file-architecture.agent_behavior.initialization"
                  ],
                  "implements": [],
                  "validates": "[ -f .jkspec/tests/dual-file-architecture/test_project_required.sh ] && echo \"Test exists\" || echo \"Test file not found\""
                }
              },
              "migration_scenario": {
                "description": "Test migration from single-file to dual-file",
                "setup": "Old source.json with both __ and user specs",
                "operation": "Run migration to split into source.json and project.json",
                "expected": "__ specs remain in source.json, user specs move to project.json",
                "test_file": "test_migration.js",
                "__meta": {
                  "description": "Migration scenario",
                  "goal": "Test scenario implemented and passing",
                  "done": true,
                  "references": [
                    "specs.__jkspec.components.dual-file-architecture.migration"
                  ],
                  "implements": [],
                  "validates": "[ -f .jkspec/tests/dual-file-architecture/test_migration.sh ] && echo \"Test exists\" || echo \"Test file not found\""
                }
              },
              "__meta": {
                "description": "Scenarios",
                "goal": "All child components marked as active",
                "done": true,
                "references": [],
                "implements": []
              }
            },
            "__meta": {
              "description": "Test scenarios",
              "goal": "All child components marked as active",
              "done": true,
              "references": [
                "specs.__jkspec.components.dual-file-architecture.architecture",
                "specs.__jkspec.components.dual-file-architecture.agent_behavior"
              ],
              "implements": []
            }
          },
          "schema_handling": {
            "description": "How schema files are handled in dual-file architecture",
            "schema_location": ".jkspec/jkspec.schema.json",
            "shared_schema": "Both source.json and project.json validate against the same schema file",
            "user_projects": {
              "option_1": {
                "approach": "Reference schema from .jkspec/ directory",
                "validation_path": ".jkspec/jkspec.schema.json",
                "note": "Schema is part of framework, gets updated with framework updates",
                "__meta": {
                  "description": "Option 1",
                  "goal": "Schema reference approach documented with validation path and implications",
                  "done": true,
                  "references": [
                    "specs.__jkspec.components.dual-file-architecture.architecture.framework_location.files.\"jkspec.schema.json\""
                  ],
                  "implements": []
                }
              },
              "option_2": {
                "approach": "Copy schema to .jkspec-project/ directory",
                "validation_path": ".jkspec-project/jkspec.schema.json",
                "note": "Allows offline validation, but needs manual sync with framework updates",
                "__meta": {
                  "description": "Option 2",
                  "goal": "Schema copy approach documented with validation path and trade-offs",
                  "done": true,
                  "references": [
                    "specs.__jkspec.components.dual-file-architecture.architecture.framework_location.files.\"jkspec.schema.json\""
                  ],
                  "implements": []
                }
              },
              "recommended": "option_1 - Keep schema in .jkspec/ as single source of truth",
              "__meta": {
                "description": "User projects",
                "goal": "All child components marked as active",
                "done": true,
                "references": [
                  "specs.__jkspec.components.schema-validation"
                ],
                "implements": []
              }
            },
            "validation_command": "Validation should always reference .jkspec/jkspec.schema.json regardless of which file is being validated",
            "__meta": {
              "description": "Schema handling",
              "goal": "All child components marked as active",
              "done": true,
              "references": [
                "specs.__jkspec.components.schema-validation"
              ],
              "implements": [
                "specs.__jkspec.components.worker.guidelines_structured.critical.rules[2]"
              ],
              "validates": "[ -f .jkspec/jkspec.schema.json ] && echo \"Schema exists\""
            }
          }
        },
        "schema-validation": {
          "__meta": {
            "type": "validation",
            "description": "JSON Schema validation for jkspec files using ajv",
            "tags": [
              "validation",
              "schema",
              "ajv"
            ],
            "purpose": "Define validation strategy for both source.json and project.json files",
            "goal": "All child components marked as active",
            "done": true,
            "implements": [
              "specs.__jkspec.components.worker.guidelines_structured.critical.rules[1]",
              ".jkspec/tests/schema-validation/"
            ],
            "references": [
              ".jkspec/jkspec.schema.json",
              "specs.__jkspec.components.impact-tracking"
            ]
          },
          "validator": {
            "tool": "ajv",
            "description": "AJV (Another JSON Schema Validator) - fast JSON schema validator",
            "package": "ajv",
            "why_ajv": "Industry-standard, performant, supports JSON Schema draft 2020-12",
            "__meta": {
              "description": "Validator",
              "goal": "Validation logic implemented and working",
              "done": true,
              "implements": [
                ".jkspec/tests/schema-validation/run_tests.sh"
              ],
              "references": [
                ".jkspec/jkspec.schema.json"
              ],
              "validates": ".specs.__jkspec.components.\"schema-validation\".files_to_validate"
            }
          },
          "files_to_validate": {
            "framework_file": {
              "path": ".jkspec/source.json",
              "schema": ".jkspec/jkspec.schema.json",
              "description": "Framework specifications including __jkspec meta specs",
              "__meta": {
                "description": "Framework file",
                "goal": "Validation logic implemented and working",
                "done": true,
                "implements": [
                  ".jkspec/source.json validation"
                ],
                "references": [
                  ".jkspec/source.json",
                  ".jkspec/jkspec.schema.json",
                  "specs.__jkspec.components.dual-file-architecture.framework_file"
                ],
                "validates": ".jkspec/source.json"
              }
            },
            "project_file": {
              "path": ".jkspec-project/project.json",
              "schema": ".jkspec/jkspec.schema.json",
              "description": "User project specifications (file MUST exist; create it before any user spec work)",
              "optional": false,
              "__meta": {
                "description": "Project file",
                "goal": "Validation logic implemented and working",
                "done": true,
                "implements": [
                  ".jkspec-project/project.json validation"
                ],
                "references": [
                  ".jkspec-project/project.json",
                  ".jkspec/jkspec.schema.json",
                  "specs.__jkspec.components.dual-file-architecture.project_file"
                ],
                "validates": ".jkspec-project/project.json"
              }
            },
            "__meta": {
              "description": "Files to validate",
              "goal": "All child components marked as active",
              "done": true,
              "implements": [
                "specs.__jkspec.components.schema-validation.validation_command"
              ],
              "references": [
                ".jkspec/jkspec.schema.json",
                "specs.__jkspec.components.dual-file-architecture"
              ]
            }
          },
          "validation_rules": {
            "required_fields": [
              "All specs must have __meta with type, description, status",
              "Root must have project and specs objects"
            ],
            "spec_id_format": "Must use kebab-case (lowercase with hyphens)",
            "status_values": [
              "draft",
              "active",
              "deprecated"
            ],
            "internal_specs": "Specs with __ prefix should only exist in source.json",
            "__meta": {
              "description": "Validation rules",
              "goal": "Rule implemented and enforced",
              "done": true,
              "implements": [
                ".jkspec/jkspec.schema.json rules"
              ],
              "references": [
                ".jkspec/jkspec.schema.json",
                "specs.__jkspec.components.dual-file-architecture.file_selection_rules",
                "specs.__jkspec.components.spec-id-format"
              ],
              "validates": ".jkspec/jkspec.schema.json"
            }
          },
          "validation_command": {
            "description": "Test script validates both source.json and project.json against schema",
            "command": "bash .jkspec/tests/schema-validation/run_tests.sh",
            "behavior": [
              "Pre-flight check: Verify ajv is installed",
              "Validate test fixtures (positive and negative cases)",
              "Validate .jkspec/source.json against schema",
              "Check if .jkspec-project/project.json exists",
              "If exists, validate .jkspec-project/project.json against schema",
              "Verify schema file itself is valid JSON",
              "Report validation results for all tests"
            ],
            "implementation": ".jkspec/tests/schema-validation/run_tests.sh",
            "note": "No need to invoke ajv directly - the test script handles all validation",
            "__meta": {
              "description": "Validation command",
              "goal": "Validation logic implemented and working",
              "done": true,
              "implements": [
                ".jkspec/tests/schema-validation/run_tests.sh"
              ],
              "references": [
                "specs.__jkspec.components.schema-validation.validator",
                "specs.__jkspec.components.schema-validation.files_to_validate",
                "specs.__jkspec.components.dual-file-architecture"
              ],
              "validates": "bash .jkspec/tests/schema-validation/run_tests.sh"
            }
          },
          "tasks": [
            {
              "__meta": {
                "description": "Add ajv package for JSON schema validation",
                "goal": "Task completed and verified",
                "done": true,
                "implements": [
                  "ajv package installation"
                ],
                "references": [
                  "specs.__jkspec.components.schema-validation.validator"
                ]
              }
            },
            {
              "__meta": {
                "description": "Create validation script that uses ajv to validate both files",
                "goal": "Task completed and verified",
                "done": true,
                "implements": [
                  "validation script implementation"
                ],
                "references": [
                  "specs.__jkspec.components.schema-validation.validator",
                  "specs.__jkspec.components.schema-validation.files_to_validate",
                  ".jkspec/jkspec.schema.json"
                ]
              }
            },
            {
              "__meta": {
                "description": "Update jkspec-validate command to use ajv validation",
                "goal": "Task completed and verified",
                "done": true,
                "implements": [
                  "jkspec-validate command"
                ],
                "references": [
                  "specs.__jkspec.components.schema-validation.validation_command",
                  "specs.__jkspec.components.schema-validation.validator"
                ]
              }
            },
            {
              "__meta": {
                "description": "Create tests for schema validation with valid and invalid specs",
                "goal": "Task completed and verified",
                "done": true,
                "implements": [
                  ".jkspec/tests/schema-validation/"
                ],
                "references": [
                  "specs.__jkspec.components.schema-validation.validator",
                  "specs.__jkspec.components.schema-validation.validation_rules",
                  ".jkspec/jkspec.schema.json"
                ],
                "validates": ".specs.__jkspec.components.\"schema-validation\".validation_rules"
              }
            }
          ]
        },
        "cli": {
          "__meta": {
            "type": "component",
            "description": "Command-line utilities that provide deterministic automation for the jkspec worker",
            "tags": [
              "cli",
              "tooling",
              "internal"
            ],
            "location": ".jkspec/cli",
            "goal": "All child components marked as active",
            "done": true
          },
          "purpose": "Document every CLI helper the worker depends on so new tooling stays traceable and versioned with specs.",
          "coverage": [
            "Bootstrap developer environments (initialize.py)",
            "Render Markdown inspection views after spec updates (make_md_view.sh)"
          ],
          "utilities": {
            "initialize": {
              "__meta": {
                "type": "cli-tool",
                "description": "Python bootstrapper that provisions a virtual environment and installs project requirements",
                "tags": [
                  "python",
                  "bootstrap",
                  "venv"
                ],
                "goal": "All child components marked as active",
                "done": true,
                "references": [
                  "specs.__jkspec.components.format.structure",
                  "specs.__jkspec.components.dual-file-architecture"
                ],
                "implements": [],
                "validates": [
                  {
                    "query": "test -f .jkspec/cli/initialize.py",
                    "description": "Verify initialize.py script exists"
                  }
                ]
              },
              "path": ".jkspec/cli/initialize.py",
              "language": "python",
              "entrypoint": "cd .jkspec/cli && python3 initialize.py [options]",
              "capabilities": [
                "Resolves the repository root automatically from the CLI directory",
                "Creates or reuses a virtual environment (default .venv) using the supplied Python interpreter",
                "Upgrades pip inside the managed environment",
                "Installs dependencies from requirements.txt unless --skip-install is provided",
                "Prints platform-aware activation instructions after provisioning",
                "Defaults virtual environment location to .jkspec/cli/.venv",
                "Requires running python3 initialize.py from the CLI directory whenever the environment must be created"
              ],
              "arguments": {
                "--python": "Interpreter used to create the virtual environment (defaults to current Python).",
                "--venv": "Target directory for the virtual environment; accepts relative or absolute paths.",
                "--requirements": "Optional requirements file to install after creation.",
                "--skip-install": "Skips dependency installation even when a requirements file exists.",
                "--recreate": "Removes the existing environment before creating a fresh one.",
                "__meta": {
                  "description": "Arguments",
                  "goal": "Arguments defined and documented",
                  "done": true,
                  "references": [],
                  "implements": [],
                  "validates": []
                }
              },
              "outputs": [
                "Managed virtual environment located at the requested path",
                "Logged subprocess commands for auditability"
              ]
            },
            "make-md-view": {
              "__meta": {
                "type": "cli-tool",
                "description": "Bash + jq renderer that converts a spec into a Markdown inspection file",
                "tags": [
                  "bash",
                  "jq",
                  "documentation"
                ],
                "goal": "All child components marked as active",
                "done": true,
                "references": [
                  "specs.__jkspec.components.format"
                ],
                "implements": [],
                "validates": [
                  {
                    "query": "test -f .jkspec/cli/make_md_view.sh",
                    "description": "Verify make_md_view.sh script exists"
                  }
                ]
              },
              "path": ".jkspec/cli/make_md_view.sh",
              "language": "bash",
              "entrypoint": "bash .jkspec/cli/make_md_view.sh [spec-id] [json-file] [output-md]",
              "capabilities": [
                "Validates arguments and target JSON before rendering",
                "Uses jq to extract the requested spec by path",
                "Renders meta, problem, requirements, implementation, testing, tasks, and notes into Markdown",
                "Creates the parent directory for the output file automatically",
                "Exits with non-zero status when inputs are invalid",
                "Works with zero arguments using sensible defaults for agent invocation"
              ],
              "requirements": [
                "jq must be installed and available on PATH",
                "Spec identifier must exist within the provided JSON file"
              ],
              "workflow": [
                "Invoke after any spec creation or update",
                "Write the Markdown output to .tmp/<spec-id>.md",
                "Surface the generated path when reporting back to users"
              ],
              "arguments": {
                "spec-id": "Spec identifier (defaults to __jkspec.components.cli)",
                "json-file": "Source JSON file (defaults to .jkspec/source.json)",
                "output-md": "Output Markdown path (defaults to .tmp/<spec-id>.md)",
                "__meta": {
                  "description": "Arguments",
                  "goal": "Arguments defined and documented",
                  "done": true,
                  "references": [],
                  "implements": [],
                  "validates": []
                }
              }
            },
            "get_all_pending_source_drafts": {
              "__meta": {
                "type": "cli-tool",
                "description": "Python helper that lists draft internal specs in source.json",
                "tags": [
                  "python",
                  "analysis",
                  "drafts"
                ],
                "goal": "Script implemented, tested, and working",
                "done": true,
                "references": [
                  "specs.__jkspec.components.format",
                  "specs.__jkspec.components.dual-file-architecture"
                ],
                "implements": [],
                "validates": [
                  {
                    "query": "test -f .jkspec/cli/get_all_pending_source_drafts.py",
                    "description": "Verify get_all_pending_source_drafts.py script exists"
                  }
                ]
              },
              "path": ".jkspec/cli/get_all_pending_source_drafts.py",
              "language": "python",
              "entrypoint": "python3 .jkspec/cli/get_all_pending_source_drafts.py",
              "capabilities": [
                "Reads .jkspec/source.json to find specs under __jkspec with __meta.done == false",
                "Emits dot-delimited spec paths for quick jq reuse",
                "Supports batch mode so other scripts can parse structured JSON results",
                "Works with zero arguments - prints draft spec paths to stdout"
              ],
              "outputs": [
                "Stdout listing specs.__jkspec.components.<name> for each draft",
                "Exit status 0 when drafts exist, 2 when none detected (unless --strict)",
                "Non-zero exit on I/O or parsing errors"
              ],
              "notes": [
                "Lives inside .jkspec/cli alongside other worker automation helpers",
                "Intended to gate releases by surfacing unfinished internal specs"
              ]
            },
            "get_all_pending_project_drafts": {
              "__meta": {
                "type": "cli-tool",
                "description": "Python helper that lists draft project specs in project.json",
                "tags": [
                  "python",
                  "analysis",
                  "project"
                ],
                "goal": "Script implemented, tested, and working",
                "done": true,
                "references": [
                  "specs.__jkspec.components.format",
                  "specs.__jkspec.components.dual-file-architecture"
                ],
                "implements": [],
                "validates": [
                  {
                    "query": "test -f .jkspec/cli/get_all_pending_project_drafts.py",
                    "description": "Verify get_all_pending_project_drafts.py script exists"
                  }
                ]
              },
              "path": ".jkspec/cli/get_all_pending_project_drafts.py",
              "language": "python",
              "entrypoint": "python3 .jkspec/cli/get_all_pending_project_drafts.py",
              "capabilities": [
                "Ensures .jkspec-project/project.json exists (creating the minimal template when missing)",
                "Lists every user spec whose __meta.done == false",
                "Supports optional export of the draft list for downstream automation",
                "Works with zero arguments - prints draft spec paths to stdout"
              ],
              "outputs": [
                "Dot-delimited spec paths like specs.project-component.feature-x",
                "Exit status 0 when drafts exist, 2 when none detected",
                "Non-zero exit on missing project file creation errors"
              ],
              "notes": [
                "Pairs with get_all_pending_source_drafts so teams can audit both scopes",
                "Must live in .jkspec/cli to keep tooling colocated with other automation scripts"
              ]
            },
            "bootstrap": {
              "__meta": {
                "type": "cli-tool",
                "description": "Python wrapper that executes the worker bootstrap first_command to initialize agent context",
                "tags": [
                  "python",
                  "bootstrap",
                  "context"
                ],
                "goal": "Script implemented, tested, and working",
                "done": true,
                "references": [
                  "specs.__jkspec.components.worker"
                ],
                "implements": [],
                "validates": [
                  {
                    "query": "test -f .jkspec/cli/bootstrap.py",
                    "description": "Verify bootstrap.py script exists"
                  }
                ]
              },
              "path": ".jkspec/cli/bootstrap.py",
              "language": "python",
              "entrypoint": "python3 .jkspec/cli/bootstrap.py",
              "purpose": "Execute the first_command from worker.bootstrap config to display worker overview for agent initialization",
              "capabilities": [
                "Runs the jq command defined in specs.__jkspec.components.worker.bootstrap.first_command",
                "Outputs high-level worker configuration overview (descriptions only, not full nested objects)",
                "Provides agents with context about available commands, policies, and guidelines",
                "Works with zero arguments - simply outputs worker JSON to stdout"
              ],
              "implementation": "Executes: jq '.specs.__jkspec.components.worker | with_entries(.value |= (if type == \"object\" then .description else . end))' .jkspec/source.json"
            },
            "__meta": {
              "description": "Utilities",
              "goal": "All child components marked as active",
              "done": true,
              "references": [
                "specs.__jkspec.components.format",
                "specs.__jkspec.components.dual-file-architecture",
                "specs.__jkspec.components.worker"
              ],
              "implements": [],
              "validates": [
                {
                  "query": "test -d .jkspec/cli",
                  "description": "Verify CLI directory exists"
                }
              ]
            },
            "spec-to-md": {
              "__meta": {
                "type": "cli-tool",
                "description": "Cross-platform Python script that renders any JSON path into readable Markdown for human review",
                "tags": [
                  "python",
                  "markdown",
                  "readability",
                  "cross-platform"
                ],
                "goal": "Script implemented, tested, and working",
                "done": true,
                "references": [
                  "specs.__jkspec.components.format"
                ],
                "implements": [],
                "validates": [
                  {
                    "query": "test -f .jkspec/cli/spec-to-md.py",
                    "description": "Verify spec-to-md.py script exists"
                  }
                ]
              },
              "path": ".jkspec/cli/spec-to-md.py",
              "language": "python",
              "entrypoint": "python3 .jkspec/cli/spec-to-md.py [json-file] [json-path] [output-md]",
              "purpose": "Generate human-readable Markdown files from any JSON spec path to enable change review after spec modifications",
              "use_cases": [
                "Review full picture after extending or modifying specs",
                "Generate documentation for specific spec components",
                "Create readable snapshots of complex nested specs",
                "Support cross-platform documentation workflows"
              ],
              "capabilities": [
                "Works with any JSON file and arbitrary JSON paths",
                "Renders nested objects, arrays, and scalars into structured Markdown",
                "Handles __meta objects with special formatting",
                "Creates parent directories for output files automatically",
                "Zero-argument invocation with sensible defaults for agent workflows",
                "Cross-platform Python implementation (no bash dependencies)",
                "Validates JSON file existence before processing",
                "Provides clear error messages for invalid paths"
              ],
              "arguments": {
                "json-file": {
                  "description": "Path to JSON file to read",
                  "default": ".jkspec/source.json",
                  "required": false
                },
                "json-path": {
                  "description": "Dot-notation path to the object to render (e.g., specs.__jkspec.components.worker)",
                  "default": "specs.__jkspec.components.cli",
                  "required": false
                },
                "output-md": {
                  "description": "Output Markdown file path",
                  "default": ".tmp/<sanitized-json-path>.md",
                  "required": false
                },
                "__meta": {
                  "description": "Arguments specification",
                  "goal": "Arguments defined and documented",
                  "done": true,
                  "references": [],
                  "implements": [],
                  "validates": []
                }
              },
              "workflow": [
                "Agent modifies or extends a spec using jkspec-worker commands",
                "Agent invokes spec-to-md.py with the modified spec path",
                "Script generates readable Markdown view in .tmp/",
                "Agent shares the .tmp/ path with user for review",
                "User reviews changes in human-readable format"
              ],
              "implementation_requirements": {
                "parsing": "Use json.loads() to read JSON file",
                "path_resolution": "Split json-path by dots and traverse nested structure",
                "rendering": {
                  "meta_objects": "Format __meta with status, description, type, tags prominently",
                  "nested_objects": "Render as markdown sections with appropriate heading levels",
                  "arrays": "Render as bullet lists or numbered items with nested content",
                  "scalars": "Display inline or as code blocks for longer strings",
                  "heading_levels": {
                    "description": "Caps heading levels at 6 (Markdown limit), then uses nested lists",
                    "levels_1_to_6": "Use standard markdown headings (# through ######)",
                    "levels_7_plus": "Switch to nested bullet lists with increasing indentation",
                    "rationale": "Markdown only supports 6 heading levels - nested lists maintain hierarchy while respecting the spec"
                  }
                },
                "error_handling": [
                  "File not found: Exit with code 2 and clear error message",
                  "Invalid JSON: Exit with code 3 and parsing error details",
                  "Path not found: Exit with code 4 and show available top-level keys",
                  "Output directory creation failure: Exit with code 5"
                ],
                "__meta": {
                  "description": "Implementation requirements",
                  "goal": "Requirements documented and ready for implementation",
                  "done": true,
                  "references": [],
                  "implements": [],
                  "validates": []
                }
              },
              "outputs": [
                "Markdown file at specified output path",
                "Success message with output file location to stdout",
                "Exit status 0 on success, non-zero on errors"
              ],
              "differences_from_make_md_view": [
                "Cross-platform Python instead of bash + jq",
                "Works with any JSON path, not just full specs",
                "Simpler interface: just 3 arguments",
                "More flexible: can render partial objects or arrays",
                "Better for automation: consistent error codes",
                "Designed for change review, not just inspection"
              ],
              "integration": {
                "worker_commands": "jkspec-extend, jkspec-deepen, jkspec-implement should auto-invoke after modifications",
                "documentation_bindings": "Update worker.documentation_bindings to include spec-to-md automation policy",
                "validation": "jkspec-validate can check if modified specs have corresponding .tmp/ MD files"
              }
            },
            "check_spec_impact": {
              "__meta": {
                "type": "cli-tool",
                "description": "Python utility that analyzes bidirectional spec dependencies (implements/references) and runs validation checks",
                "done": true,
                "tags": [
                  "python",
                  "analysis",
                  "impact",
                  "dependencies"
                ],
                "goal": "Script implemented, tested, and working",
                "references": [
                  "specs.__jkspec.components.impact-tracking",
                  "specs.__jkspec.components.traceability"
                ],
                "implements": [],
                "validates": [
                  {
                    "query": "test -f .jkspec/cli/check_spec_impact.py",
                    "description": "Verify check_spec_impact.py script exists"
                  }
                ]
              },
              "path": ".jkspec/cli/check_spec_impact.py",
              "language": "python",
              "entrypoint": "python3 .jkspec/cli/check_spec_impact.py <spec-path>",
              "purpose": "Show impact of changing a spec by displaying downstream dependencies (implements), upstream dependencies (references), and running validation queries",
              "capabilities": [
                "Takes a spec path as argument",
                "Loads spec __meta to read implements and references arrays",
                "Shows downstream dependencies (what depends on this spec)",
                "Shows upstream dependencies (what this spec depends on)",
                "Runs validates query if present and shows results",
                "Displays status (done/pending) for each dependency",
                "Provides summary count of total dependencies"
              ],
              "outputs": [
                "Formatted impact analysis with downstream and upstream dependencies",
                "Validation results if validates query is present",
                "Exit status 0 on success, non-zero on errors"
              ],
              "use_cases": [
                "Before refactoring a core spec, check what will be affected",
                "When a spec has issues, check what it depends on",
                "Verify bidirectional tracking is set up correctly",
                "Validate consistency after making changes"
              ]
            }
          },
          "guidelines": [
            "Add every new CLI helper to this component before exposing it to users or agents",
            "Prefer cross-platform runtimes (Python or POSIX shell) and document platform assumptions",
            "Run initialize.py before other tooling to guarantee dependencies are installed",
            "Always execute make_md_view.sh immediately after modifying specs so reviewers have a Markdown snapshot",
            "When provisioning tooling, cd into .jkspec/cli and run python3 initialize.py so the managed venv is created in-place.",
            "CLI utilities MUST NOT require arguments - all parameters should have sensible defaults to allow zero-config invocation by agents",
            "Optional flags (--output, --show-config, etc.) are permitted for advanced use cases, but the tool must work correctly when called with no arguments",
            "Agents should be able to invoke any CLI utility with just: python3 .jkspec/cli/<script>.py"
          ]
        },
        "__meta": {
          "description": "Component specifications",
          "goal": "All child components marked as active",
          "done": true
        },
        "impact-tracking": {
          "__meta": {
            "type": "meta-system",
            "description": "System for tracking spec dependencies and ensuring updates propagate correctly across source.json",
            "done": true,
            "goal": "Agents can identify and update all affected specs when making changes without needing full context",
            "implements": [
              "specs.__jkspec.components.cli.utilities.check_spec_impact"
            ],
            "references": [
              "specs.__jkspec.components.format.structure.specs.spec_schema"
            ],
            "validates": "[paths(objects | select(has(\"__meta\") and (.implements != null or .references != null)))] | length"
          },
          "problem": {
            "description": "When refactoring core specs (like __meta structure), dependent specs and implementations can become outdated",
            "example": "Changing status to done required updating CLI scripts, but agent needed to manually discover the connection",
            "challenge": "How can agents know what else needs updating without loading entire source.json into context?"
          },
          "solution": {
            "approach": "Bidirectional reference tracking using spec paths",
            "components": [
              "implements: array - specs/implementations that depend on this spec",
              "references: array - specs this spec depends on",
              "validates: jq query - automated validation query to check consistency"
            ]
          },
          "spec_fields": {
            "implements": {
              "description": "Array of spec paths that implement or depend on this spec definition",
              "format": "Dot-notation paths (e.g., specs.__jkspec.components.cli.utilities.get_all_pending_source_drafts)",
              "purpose": "When this spec changes, agent knows what implementations to check/update",
              "example": [
                "specs.__jkspec.components.cli.utilities.get_all_pending_source_drafts",
                "specs.__jkspec.components.cli.utilities.get_all_pending_project_drafts"
              ],
              "required": true
            },
            "references": {
              "description": "Array of spec paths that this spec depends on",
              "format": "Dot-notation paths",
              "purpose": "Agent knows what specs to check when this implementation has issues",
              "example": [
                "specs.__jkspec.components.format.structure.specs.spec_schema"
              ],
              "required": true
            },
            "validates": {
              "description": "Optional jq query that checks if implementations are consistent with this spec",
              "format": "jq command as string",
              "purpose": "Automated consistency checking",
              "example": "jq '[paths(objects | select(has(\\\"__meta\\\") and (..__meta.status // false)))] | length' .jkspec/source.json"
            }
          },
          "workflow": {
            "when_changing_spec": [
              "Agent reads spec.__meta.implements array",
              "Agent queries each path to load affected specs",
              "Agent updates each affected spec/implementation",
              "Agent validates using validates query if present",
              "Agent marks original spec as done when all implements updated"
            ],
            "when_fixing_implementation": [
              "Agent reads implementation.references array",
              "Agent queries referenced specs to understand current requirements",
              "Agent updates implementation to match",
              "Agent tests implementation"
            ]
          },
          "example_usage": {
            "core_spec_with_implements": {
              "__meta": {
                "description": "Spec schema definition with __meta structure",
                "done": true,
                "implements": [
                  "specs.__jkspec.components.cli.utilities.get_all_pending_source_drafts",
                  "specs.__jkspec.components.cli.utilities.get_all_pending_project_drafts",
                  "specs.__jkspec.components.worker.commands_definitions.implement"
                ],
                "validates": "jq '[paths(objects | select(has(\\\"__meta\\\") and (..__meta.status // false)))] | length' .jkspec/source.json",
                "references": [
                  "specs.__jkspec.components.format.structure.specs.spec_schema"
                ]
              }
            },
            "implementation_with_references": {
              "__meta": {
                "description": "CLI tool to find incomplete specs",
                "done": true,
                "references": [
                  "specs.__jkspec.components.format.structure.specs.spec_schema"
                ],
                "implements": [
                  "specs.__jkspec.components.format.structure.specs.spec_schema"
                ]
              }
            }
          },
          "cli_tool": {
            "name": "check_spec_impact.py",
            "purpose": "Given a spec path, show what would be affected by changes",
            "usage": "python3 .jkspec/cli/check_spec_impact.py specs.__jkspec.components.format.structure.specs.spec_schema",
            "output": "List of all specs that implement or reference the given spec"
          },
          "benefits": [
            "Minimal context needed - agent only loads implements array",
            "Bidirectional tracking - can navigate up or down dependency tree",
            "Automated validation - validates query catches inconsistencies",
            "Self-documenting - specs explicitly declare their dependencies",
            "Scalable - works even as source.json grows large"
          ],
          "implementation_priority": "high - prevents drift and ensures consistency",
          "enforcement": {
            "rule": "Every __meta object MUST review and update implements/references fields",
            "when": "On spec creation, modification, or when dependencies change",
            "worker_behavior": "Before marking any spec as done, worker MUST verify implements and references are current",
            "rationale": "Prevents spec drift and ensures bidirectional traceability is always maintained"
          },
          "rollout_plan": {
            "__meta": {
              "description": "Plan to systematically add implements/references to all specs",
              "goal": "All specs have proper dependency tracking",
              "done": true,
              "references": [
                "specs.__jkspec.components.impact-tracking"
              ],
              "implements": []
            },
            "approach": "Delegate to multiple jkspec-worker agents, one per component",
            "phases": [
              {
                "phase": 1,
                "name": "Core format specs",
                "components": [
                  "format"
                ],
                "rationale": "Everything depends on format, start here"
              },
              {
                "phase": 2,
                "name": "Infrastructure components",
                "components": [
                  "schema-validation",
                  "dual-file-architecture",
                  "impact-tracking"
                ],
                "rationale": "Foundation systems that other components reference"
              },
              {
                "phase": 3,
                "name": "Worker and CLI",
                "components": [
                  "worker",
                  "cli"
                ],
                "rationale": "Main operational components with many dependencies"
              },
              {
                "phase": 4,
                "name": "Pattern and documentation",
                "components": [
                  "traceability",
                  "depth-system",
                  "readme-documentation"
                ],
                "rationale": "Pattern libraries and documentation generators"
              }
            ],
            "per_component_task": "For each component, spawn a worker to: 1) Identify all __meta objects within that component, 2) Analyze what each spec implements or references, 3) Add implements/references/validates fields, 4) Validate changes",
            "completion_summary": {
              "total_components": 9,
              "components_completed": [
                "format",
                "schema-validation",
                "dual-file-architecture",
                "impact-tracking",
                "worker",
                "cli",
                "traceability",
                "depth-system",
                "readme-documentation"
              ],
              "total_meta_objects_updated": 218,
              "phase_1_format": {
                "specs_updated": 7,
                "status": "complete"
              },
              "phase_2_infrastructure": {
                "specs_updated": 62,
                "components": [
                  "schema-validation",
                  "dual-file-architecture",
                  "impact-tracking"
                ],
                "status": "complete"
              },
              "phase_3_worker_cli": {
                "specs_updated": 74,
                "components": [
                  "worker",
                  "cli"
                ],
                "status": "complete"
              },
              "phase_4_patterns_docs": {
                "specs_updated": 33,
                "components": [
                  "traceability",
                  "depth-system",
                  "readme-documentation"
                ],
                "status": "complete"
              },
              "enforcement": "Added to worker.guidelines_structured.critical.rules",
              "validation": "All changes validated against jkspec.schema.json"
            }
          },
          "cascade_invalidation": {
            "__meta": {
              "description": "System for automatically marking dependent specs as done=false when their references change",
              "goal": "Prevent outdated implementations by cascading changes through dependency tree",
              "done": true
            },
            "concept": "When a spec is modified (done status changes, content changes), all specs in its implements array should be automatically marked as done=false to trigger re-validation",
            "use_case": "Documentation references 6 core specs. If any of those specs change, documentation should be marked done=false so it gets regenerated with updated content",
            "enforcement_rule": "Before marking any spec as done=true, check if any of its references have changed since last validation. If yes, keep it as done=false until re-validated",
            "workflow": [
              "User modifies spec A",
              "System queries spec A.__meta.implements array",
              "For each spec in implements array, mark it as done=false",
              "Worker sees these as pending tasks in get_all_pending_drafts",
              "Worker re-validates/re-implements those specs",
              "Dependencies stay in sync automatically"
            ],
            "cli_tool": {
              "name": "enforce_cascade_invalidation.py",
              "purpose": "Check all specs with references and mark them done=false if any reference has changed",
              "usage": "python3 .jkspec/cli/enforce_cascade_invalidation.py [--spec-path <path>] [--dry-run]",
              "options": [
                "--spec-path: Check specific spec only (default: check all specs)",
                "--dry-run: Show what would be invalidated without making changes",
                "--validate: Also run validates queries after invalidation"
              ]
            },
            "tasks": [
              {
                "__meta": {
                  "description": "Create enforce_cascade_invalidation.py CLI tool",
                  "goal": "Tool exists and works for both source.json and project.json",
                  "done": true
                }
              },
              {
                "__meta": {
                  "description": "Add cascade invalidation to worker.guidelines_structured.high priority",
                  "goal": "Worker automatically checks cascade when marking specs done",
                  "done": true
                }
              },
              {
                "__meta": {
                  "description": "Run cascade check on readme-documentation references",
                  "goal": "Verify all 6 referenced specs are current and mark documentation if any changed",
                  "done": true,
                  "result": "Checked all 6 referenced specs (worker, format, depth-system, traceability, dual-file-architecture, schema-validation) - all are done=true, documentation is in sync"
                }
              }
            ]
          }
        }
      }
    }
  }
}
